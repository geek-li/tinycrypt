; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\odzhan\tinycrypt\hash\jh\ref.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_roundconstant_zero
PUBLIC	_S
_DATA	SEGMENT
_S	DB	09H
	DB	00H
	DB	04H
	DB	0bH
	DB	0dH
	DB	0cH
	DB	03H
	DB	0fH
	DB	01H
	DB	0aH
	DB	02H
	DB	06H
	DB	07H
	DB	05H
	DB	08H
	DB	0eH
	DB	03H
	DB	0cH
	DB	06H
	DB	0dH
	DB	05H
	DB	07H
	DB	01H
	DB	09H
	DB	0fH
	DB	02H
	DB	00H
	DB	04H
	DB	0bH
	DB	0aH
	DB	0eH
	DB	08H
_DATA	ENDS
CONST	SEGMENT
_roundconstant_zero DB 06H
	DB	0aH
	DB	00H
	DB	09H
	DB	0eH
	DB	06H
	DB	06H
	DB	07H
	DB	0fH
	DB	03H
	DB	0bH
	DB	0cH
	DB	0cH
	DB	09H
	DB	00H
	DB	08H
	DB	0bH
	DB	02H
	DB	0fH
	DB	0bH
	DB	01H
	DB	03H
	DB	06H
	DB	06H
	DB	0eH
	DB	0aH
	DB	09H
	DB	05H
	DB	07H
	DB	0dH
	DB	03H
	DB	0eH
	DB	03H
	DB	0aH
	DB	0dH
	DB	0eH
	DB	0cH
	DB	01H
	DB	07H
	DB	05H
	DB	01H
	DB	02H
	DB	07H
	DB	07H
	DB	05H
	DB	00H
	DB	09H
	DB	09H
	DB	0dH
	DB	0aH
	DB	02H
	DB	0fH
	DB	05H
	DB	09H
	DB	00H
	DB	0bH
	DB	00H
	DB	06H
	DB	06H
	DB	07H
	DB	03H
	DB	02H
	DB	02H
	DB	0aH
CONST	ENDS
PUBLIC	_R8
; Function compile flags: /Ogspy
;	COMDAT _R8
_TEXT	SEGMENT
_roundconstant_expanded$ = -516				; size = 256
_tem$ = -260						; size = 256
_i$ = -4						; size = 4
_state$ = 8						; size = 4
_R8	PROC						; COMDAT
; File c:\odzhan\tinycrypt\hash\jh\ref.c
; Line 70
	push	ebp
	mov	ebp, esp
	sub	esp, 516				; 00000204H
	push	esi
; Line 76
	mov	esi, DWORD PTR _state$[ebp]
	push	edi
	xor	eax, eax
	mov	edi, 256				; 00000100H
$LL18@R8:
; Line 77
	mov	dl, al
	and	dl, 3
	mov	cl, 3
	sub	cl, dl
	mov	edx, eax
	shr	edx, 2
	mov	dl, BYTE PTR [edx+esi+408]
	shr	dl, cl
	and	dl, 1
	mov	BYTE PTR _roundconstant_expanded$[ebp+eax], dl
	inc	eax
	cmp	eax, edi
	jb	SHORT $LL18@R8
; Line 81
	xor	eax, eax
$LL15@R8:
; Line 82
	movzx	ecx, BYTE PTR _roundconstant_expanded$[ebp+eax]
	movzx	edx, BYTE PTR [esi+eax+152]
	add	ecx, ecx
	mov	cl, BYTE PTR _S[edx+ecx*8]
	mov	BYTE PTR _tem$[ebp+eax], cl
	inc	eax
	cmp	eax, edi
	jb	SHORT $LL15@R8
; Line 86
	and	DWORD PTR _i$[ebp], 0
	push	ebx
$LL12@R8:
	mov	esi, DWORD PTR _i$[ebp]
	lea	esi, DWORD PTR _tem$[ebp+esi]
	mov	cl, BYTE PTR [esi]
	add	DWORD PTR _i$[ebp], 2
	mov	al, cl
	shr	al, 3
	mov	dl, cl
	add	dl, dl
	xor	al, dl
	and	al, 15					; 0000000fH
	mov	dl, cl
	shr	dl, 2
	and	dl, 2
	xor	al, dl
	xor	al, BYTE PTR [esi+1]
	mov	dl, al
	shr	dl, 3
	mov	bl, al
	add	bl, bl
	xor	dl, bl
	mov	BYTE PTR [esi+1], al
	shr	al, 2
	and	dl, 15					; 0000000fH
	and	al, 2
	xor	dl, al
	xor	dl, cl
	mov	BYTE PTR [esi], dl
	cmp	DWORD PTR _i$[ebp], edi
	jb	SHORT $LL12@R8
; Line 91
	xor	esi, esi
	pop	ebx
$LL9@R8:
; Line 92
	lea	eax, DWORD PTR _tem$[ebp+esi+3]
	mov	cl, BYTE PTR [eax-1]
; Line 93
	mov	dl, BYTE PTR [eax]
	add	esi, 4
	mov	BYTE PTR [eax-1], dl
; Line 94
	mov	BYTE PTR [eax], cl
	cmp	esi, edi
	jb	SHORT $LL9@R8
; Line 98
	mov	esi, DWORD PTR _state$[ebp]
	lea	edx, DWORD PTR [esi+280]
	lea	ecx, DWORD PTR _tem$[ebp+1]
	mov	edi, 128				; 00000080H
$LL6@R8:
; Line 99
	mov	al, BYTE PTR [ecx-1]
	mov	BYTE PTR [edx-128], al
; Line 100
	mov	al, BYTE PTR [ecx]
	add	ecx, 2
	mov	BYTE PTR [edx], al
	inc	edx
	dec	edi
	jne	SHORT $LL6@R8
; Line 104
	push	64					; 00000040H
	lea	eax, DWORD PTR [esi+281]
	pop	esi
$LL3@R8:
; Line 105
	mov	cl, BYTE PTR [eax-1]
; Line 106
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [eax-1], dl
; Line 107
	mov	BYTE PTR [eax], cl
	add	eax, 2
	dec	esi
	jne	SHORT $LL3@R8
	pop	edi
	pop	esi
; Line 109
	leave
	ret	0
_R8	ENDP
_TEXT	ENDS
PUBLIC	_update_roundconstant
; Function compile flags: /Ogspy
;	COMDAT _update_roundconstant
_TEXT	SEGMENT
_tem$ = -64						; size = 64
_state$ = 8						; size = 4
_update_roundconstant PROC				; COMDAT
; Line 116
	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
; Line 121
	xor	eax, eax
$LL15@update_rou:
	mov	ecx, DWORD PTR _state$[ebp]
	movzx	ecx, BYTE PTR [ecx+eax+408]
	mov	cl, BYTE PTR _S[ecx]
	mov	BYTE PTR _tem$[ebp+eax], cl
	inc	eax
	cmp	eax, 64					; 00000040H
	jl	SHORT $LL15@update_rou
; Line 124
	push	ebx
	push	esi
	push	edi
	xor	edi, edi
$LL12@update_rou:
	lea	esi, DWORD PTR _tem$[ebp+edi]
	mov	cl, BYTE PTR [esi]
	mov	al, cl
	shr	al, 3
	mov	dl, cl
	add	dl, dl
	xor	al, dl
	and	al, 15					; 0000000fH
	mov	dl, cl
	shr	dl, 2
	and	dl, 2
	xor	al, dl
	xor	al, BYTE PTR [esi+1]
	add	edi, 2
	mov	dl, al
	shr	dl, 3
	mov	bl, al
	add	bl, bl
	xor	dl, bl
	mov	BYTE PTR [esi+1], al
	shr	al, 2
	and	dl, 15					; 0000000fH
	and	al, 2
	xor	dl, al
	xor	dl, cl
	mov	BYTE PTR [esi], dl
	cmp	edi, 64					; 00000040H
	jl	SHORT $LL12@update_rou
; Line 129
	xor	esi, esi
$LL9@update_rou:
; Line 130
	lea	eax, DWORD PTR _tem$[ebp+esi+3]
	mov	cl, BYTE PTR [eax-1]
; Line 131
	mov	dl, BYTE PTR [eax]
	add	esi, 4
	mov	BYTE PTR [eax-1], dl
; Line 132
	mov	BYTE PTR [eax], cl
	cmp	esi, 64					; 00000040H
	jl	SHORT $LL9@update_rou
; Line 136
	mov	esi, DWORD PTR _state$[ebp]
	push	32					; 00000020H
	lea	ecx, DWORD PTR [esi+440]
	lea	eax, DWORD PTR _tem$[ebp+1]
	pop	edi
$LL6@update_rou:
; Line 137
	mov	dl, BYTE PTR [eax-1]
	mov	BYTE PTR [ecx-32], dl
; Line 138
	mov	dl, BYTE PTR [eax]
	add	eax, 2
	mov	BYTE PTR [ecx], dl
	inc	ecx
	dec	edi
	jne	SHORT $LL6@update_rou
; Line 142
	push	16					; 00000010H
	lea	eax, DWORD PTR [esi+441]
	pop	esi
$LL3@update_rou:
; Line 143
	mov	cl, BYTE PTR [eax-1]
; Line 144
	mov	dl, BYTE PTR [eax]
	mov	BYTE PTR [eax-1], dl
; Line 145
	mov	BYTE PTR [eax], cl
	add	eax, 2
	dec	esi
	jne	SHORT $LL3@update_rou
	pop	edi
	pop	esi
	pop	ebx
; Line 147
	leave
	ret	0
_update_roundconstant ENDP
_TEXT	ENDS
PUBLIC	_E8_initialgroup
; Function compile flags: /Ogspy
;	COMDAT _E8_initialgroup
_TEXT	SEGMENT
_tem$ = -264						; size = 256
tv425 = -8						; size = 4
tv323 = -1						; size = 1
_state$ = 8						; size = 4
_E8_initialgroup PROC					; COMDAT
; Line 153
	push	ebp
	mov	ebp, esp
	sub	esp, 264				; 00000108H
	push	ebx
; Line 162
	lea	ecx, DWORD PTR _tem$[ebp]
	push	esi
	mov	esi, DWORD PTR _state$[ebp]
	xor	eax, eax
	sub	ecx, 512				; 00000200H
	push	edi
	mov	DWORD PTR tv425[ebp], ecx
$LL13@E8_initial:
; Line 164
	mov	dl, al
	mov	cl, 7
	and	dl, cl
	sub	cl, dl
	mov	ebx, eax
	shr	ebx, 3
	mov	bl, BYTE PTR [ebx+esi+24]
	shr	bl, cl
	lea	edx, DWORD PTR [eax+256]
	shr	edx, 3
	mov	dl, BYTE PTR [edx+esi+24]
	shr	dl, cl
; Line 167
	and	bl, 1
	mov	BYTE PTR tv323[ebp], cl
	add	bl, bl
	and	dl, 1
	or	dl, bl
	lea	ecx, DWORD PTR [eax+512]
	shr	ecx, 3
	mov	bl, BYTE PTR [ecx+esi+24]
	mov	cl, BYTE PTR tv323[ebp]
	shr	bl, cl
	add	dl, dl
	lea	ecx, DWORD PTR [eax+768]
	shr	ecx, 3
	and	bl, 1
	or	dl, bl
	mov	bl, BYTE PTR [ecx+esi+24]
	mov	cl, BYTE PTR tv323[ebp]
	shr	bl, cl
	mov	ecx, DWORD PTR tv425[ebp]
	add	dl, dl
	and	bl, 1
	or	dl, bl
	mov	BYTE PTR [ecx+eax+512], dl
	inc	eax
	cmp	eax, 256				; 00000100H
	jb	SHORT $LL13@E8_initial
; Line 170
	pop	edi
	lea	eax, DWORD PTR [esi+153]
	pop	esi
	xor	ecx, ecx
	pop	ebx
$LL3@E8_initial:
; Line 171
	mov	dl, BYTE PTR _tem$[ebp+ecx]
	mov	BYTE PTR [eax-1], dl
; Line 172
	mov	dl, BYTE PTR _tem$[ebp+ecx+128]
	mov	BYTE PTR [eax], dl
	inc	ecx
	add	eax, 2
	cmp	ecx, 128				; 00000080H
	jb	SHORT $LL3@E8_initial
; Line 174
	leave
	ret	0
_E8_initialgroup ENDP
_TEXT	ENDS
PUBLIC	_E8_finaldegroup
; Function compile flags: /Ogspy
;	COMDAT _E8_finaldegroup
_TEXT	SEGMENT
_tem$ = -272						; size = 256
tv549 = -16						; size = 4
tv519 = -12						; size = 4
tv513 = -8						; size = 4
tv433 = -4						; size = 4
_i$ = 8							; size = 4
_state$ = 8						; size = 4
_E8_finaldegroup PROC					; COMDAT
; Line 179
	push	ebp
	mov	ebp, esp
; Line 184
	mov	edx, DWORD PTR _state$[ebp]
	sub	esp, 272				; 00000110H
	push	ebx
	push	esi
	push	edi
	xor	edi, edi
	lea	eax, DWORD PTR [edx+153]
	mov	esi, 128				; 00000080H
$LL6@E8_finalde:
; Line 185
	mov	cl, BYTE PTR [eax-1]
	mov	BYTE PTR _tem$[ebp+edi], cl
; Line 186
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _tem$[ebp+edi+128], cl
	inc	edi
	add	eax, 2
	cmp	edi, esi
	jb	SHORT $LL6@E8_finalde
; Line 193
	and	DWORD PTR _i$[ebp], 0
	xor	al, al
	lea	edi, DWORD PTR [edx+24]
	mov	ecx, esi
	rep stosb
	lea	eax, DWORD PTR _tem$[ebp]
	mov	DWORD PTR tv513[ebp], 512		; 00000200H
	sub	DWORD PTR tv513[ebp], eax
	mov	DWORD PTR tv519[ebp], 768		; 00000300H
	sub	DWORD PTR tv519[ebp], eax
$LL13@E8_finalde:
; Line 199
	mov	esi, DWORD PTR _i$[ebp]
	mov	eax, esi
	lea	edi, DWORD PTR _tem$[ebp+esi]
	push	7
	pop	ecx
	and	eax, ecx
	sub	ecx, eax
	mov	al, BYTE PTR [edi]
	mov	bl, al
	shr	bl, 3
	and	bl, 1
	shl	bl, cl
	shr	esi, 3
	lea	esi, DWORD PTR [esi+edx+24]
	mov	DWORD PTR tv433[ebp], ecx
	or	BYTE PTR [esi], bl
; Line 200
	mov	esi, DWORD PTR tv513[ebp]
	add	esi, edi
	lea	ecx, DWORD PTR [esi-256]
	shr	ecx, 3
	lea	ecx, DWORD PTR [ecx+edx+24]
	mov	DWORD PTR tv549[ebp], ecx
	mov	ecx, DWORD PTR tv433[ebp]
	mov	bl, al
	shr	bl, 2
	and	bl, 1
	shl	bl, cl
	mov	ecx, DWORD PTR tv549[ebp]
; Line 201
	shr	esi, 3
	lea	esi, DWORD PTR [esi+edx+24]
	or	BYTE PTR [ecx], bl
	mov	ecx, DWORD PTR tv433[ebp]
	mov	bl, al
	shr	bl, 1
	and	bl, 1
	shl	bl, cl
; Line 202
	mov	ecx, DWORD PTR tv519[ebp]
	add	ecx, edi
	shr	ecx, 3
	or	BYTE PTR [esi], bl
	lea	esi, DWORD PTR [ecx+edx+24]
	mov	ecx, DWORD PTR tv433[ebp]
	and	al, 1
	shl	al, cl
	or	BYTE PTR [esi], al
	inc	DWORD PTR _i$[ebp]
	cmp	DWORD PTR _i$[ebp], 256			; 00000100H
	jb	$LL13@E8_finalde
	pop	edi
	pop	esi
	pop	ebx
; Line 204
	leave
	ret	0
_E8_finaldegroup ENDP
_TEXT	ENDS
PUBLIC	_E8
; Function compile flags: /Ogspy
;	COMDAT _E8
_TEXT	SEGMENT
_state$ = 8						; size = 4
_E8	PROC						; COMDAT
; Line 208
	push	esi
; Line 214
	mov	esi, DWORD PTR _state$[esp]
	push	edi
	xor	eax, eax
$LL6@E8:
	mov	cl, BYTE PTR _roundconstant_zero[eax]
	mov	BYTE PTR [esi+eax+408], cl
	inc	eax
	cmp	eax, 64					; 00000040H
	jb	SHORT $LL6@E8
; Line 217
	push	esi
	call	_E8_initialgroup
	pop	ecx
	push	42					; 0000002aH
	pop	edi
$LL3@E8:
; Line 221
	push	esi
	call	_R8
; Line 222
	push	esi
	call	_update_roundconstant
	dec	edi
	pop	ecx
	pop	ecx
	jne	SHORT $LL3@E8
; Line 226
	push	esi
	call	_E8_finaldegroup
	pop	ecx
	pop	edi
	pop	esi
; Line 227
	ret	0
_E8	ENDP
_TEXT	ENDS
PUBLIC	_F8
; Function compile flags: /Ogspy
;	COMDAT _F8
_TEXT	SEGMENT
_state$ = 8						; size = 4
_F8	PROC						; COMDAT
; Line 231
	push	esi
; Line 235
	mov	esi, DWORD PTR _state$[esp]
	push	64					; 00000040H
	lea	eax, DWORD PTR [esi+24]
	pop	ecx
$LL6@F8:
	mov	dl, BYTE PTR [eax+448]
	xor	BYTE PTR [eax], dl
	inc	eax
	dec	ecx
	jne	SHORT $LL6@F8
; Line 238
	push	esi
	call	_E8
	pop	ecx
	push	64					; 00000040H
	pop	ecx
	lea	eax, DWORD PTR [esi+88]
	pop	esi
$LL3@F8:
; Line 241
	mov	dl, BYTE PTR [eax+384]
	xor	BYTE PTR [eax], dl
	inc	eax
	dec	ecx
	jne	SHORT $LL3@F8
; Line 242
	ret	0
_F8	ENDP
_TEXT	ENDS
PUBLIC	_Init
; Function compile flags: /Ogspy
;	COMDAT _Init
_TEXT	SEGMENT
_state$ = 8						; size = 4
_hashbitlen$ = 12					; size = 4
_Init	PROC						; COMDAT
; Line 249
	mov	edx, DWORD PTR _state$[esp-4]
	push	ebx
; Line 252
	mov	ebx, DWORD PTR _hashbitlen$[esp]
	push	esi
	push	edi
	xor	eax, eax
	mov	DWORD PTR [edx+8], eax
	mov	DWORD PTR [edx+12], eax
	mov	DWORD PTR [edx+16], eax
	mov	DWORD PTR [edx+20], eax
; Line 255
	push	64					; 00000040H
	mov	DWORD PTR [edx], ebx
	xor	al, al
	lea	edi, DWORD PTR [edx+472]
	pop	ecx
	rep stosb
; Line 258
	lea	edi, DWORD PTR [edx+24]
	mov	ecx, 128				; 00000080H
	rep stosb
; Line 262
	mov	BYTE PTR [edx+25], bl
; Line 263
	sar	ebx, 8
; Line 265
	push	edx
	mov	BYTE PTR [edx+24], bl
	call	_F8
	pop	ecx
	pop	edi
	pop	esi
; Line 267
	xor	eax, eax
	pop	ebx
; Line 268
	ret	0
_Init	ENDP
_TEXT	ENDS
PUBLIC	_Update
; Function compile flags: /Ogspy
;	COMDAT _Update
_TEXT	SEGMENT
tv82 = -16						; size = 8
_index$ = -8						; size = 8
_state$ = 8						; size = 4
_data$ = 12						; size = 4
_databitlen$ = 16					; size = 8
_Update	PROC						; COMDAT
; Line 272
	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
; Line 275
	mov	edx, DWORD PTR _databitlen$[ebp]
	mov	eax, DWORD PTR _databitlen$[ebp+4]
	push	ebx
	mov	ebx, DWORD PTR _state$[ebp]
	add	DWORD PTR [ebx+8], edx
	push	esi
; Line 282
	mov	esi, DWORD PTR [ebx+16]
	adc	DWORD PTR [ebx+12], eax
	mov	eax, DWORD PTR [ebx+20]
	and	DWORD PTR _index$[ebp], 0
	and	DWORD PTR _index$[ebp+4], 0
	push	edi
	test	eax, eax
	jne	SHORT $LN15@Update
	test	esi, esi
	je	SHORT $LN23@Update
$LN15@Update:
	mov	edi, esi
	add	edi, edx
	mov	ecx, eax
	adc	ecx, DWORD PTR _databitlen$[ebp+4]
	test	ecx, ecx
	ja	SHORT $LN23@Update
	jb	SHORT $LN22@Update
	cmp	edi, 512				; 00000200H
	jae	SHORT $LN23@Update
$LN22@Update:
; Line 284
	shrd	esi, eax, 3
	mov	ecx, edx
	xor	edi, edi
	and	ecx, 7
	shr	eax, 3
	or	ecx, edi
	lea	edi, DWORD PTR [esi+ebx+472]
	jne	SHORT $LN9@Update
	push	64					; 00000040H
	jmp	SHORT $LN31@Update
$LN9@Update:
; Line 286
	push	65					; 00000041H
$LN31@Update:
; Line 287
	mov	eax, DWORD PTR _databitlen$[ebp+4]
	pop	ecx
	sub	ecx, esi
	mov	esi, DWORD PTR _data$[ebp]
	rep movsb
	add	DWORD PTR [ebx+16], edx
	adc	DWORD PTR [ebx+20], eax
; Line 288
	and	DWORD PTR _databitlen$[ebp], 0
	and	DWORD PTR _databitlen$[ebp+4], 0
	mov	edx, DWORD PTR _databitlen$[ebp]
$LN23@Update:
; Line 292
	mov	eax, DWORD PTR [ebx+20]
	mov	ecx, DWORD PTR [ebx+16]
	test	eax, eax
	jne	SHORT $LN17@Update
	test	ecx, ecx
	je	SHORT $LN28@Update
$LN17@Update:
	mov	esi, ecx
	add	esi, edx
	mov	edi, eax
	adc	edi, DWORD PTR _databitlen$[ebp+4]
	mov	DWORD PTR tv82[ebp+4], edi
	jne	SHORT $LN18@Update
	cmp	esi, 512				; 00000200H
	jb	SHORT $LN28@Update
$LN18@Update:
; Line 293
	mov	esi, DWORD PTR _data$[ebp]
	shrd	ecx, eax, 3
	shr	eax, 3
	push	64					; 00000040H
	mov	edx, eax
	mov	eax, ecx
	pop	ecx
	sub	ecx, eax
	lea	edi, DWORD PTR [eax+ebx+472]
	rep movsb
; Line 294
	mov	eax, DWORD PTR [ebx+16]
	mov	ecx, DWORD PTR [ebx+20]
	mov	edi, eax
	mov	esi, ecx
	shrd	edi, esi, 3
	push	64					; 00000040H
	pop	edx
	shr	esi, 3
	sub	edx, edi
	mov	DWORD PTR _index$[ebp], edx
	push	0
	pop	edx
	sbb	edx, esi
; Line 295
	add	eax, -512				; fffffe00H
	adc	ecx, -1
	add	DWORD PTR _databitlen$[ebp], eax
; Line 296
	push	ebx
	mov	DWORD PTR _index$[ebp+4], edx
	adc	DWORD PTR _databitlen$[ebp+4], ecx
	call	_F8
; Line 297
	and	DWORD PTR [ebx+16], 0
	and	DWORD PTR [ebx+20], 0
	mov	edx, DWORD PTR _databitlen$[ebp]
	pop	ecx
$LN28@Update:
; Line 301
	cmp	DWORD PTR _databitlen$[ebp+4], 0
	ja	SHORT $LL19@Update
	cmp	edx, 512				; 00000200H
	jb	SHORT $LN20@Update
$LL19@Update:
; Line 302
	mov	esi, DWORD PTR _index$[ebp]
	add	esi, DWORD PTR _data$[ebp]
	push	64					; 00000040H
	pop	ecx
	lea	edi, DWORD PTR [ebx+472]
; Line 303
	push	ebx
	rep movsb
	call	_F8
	add	DWORD PTR _index$[ebp], 64		; 00000040H
	pop	ecx
	adc	DWORD PTR _index$[ebp+4], 0
	add	DWORD PTR _databitlen$[ebp], -512	; fffffe00H
	adc	DWORD PTR _databitlen$[ebp+4], -1
	cmp	DWORD PTR _databitlen$[ebp+4], 0
	ja	SHORT $LL19@Update
; Line 301
	jb	SHORT $LN27@Update
	cmp	DWORD PTR _databitlen$[ebp], 512	; 00000200H
	jae	SHORT $LL19@Update
$LN27@Update:
	mov	edx, DWORD PTR _databitlen$[ebp]
$LN20@Update:
; Line 307
	xor	ecx, ecx
	cmp	DWORD PTR _databitlen$[ebp+4], ecx
	ja	SHORT $LN21@Update
	cmp	edx, ecx
	jbe	SHORT $LN3@Update
$LN21@Update:
; Line 309
	mov	esi, DWORD PTR _index$[ebp]
	mov	eax, edx
	and	eax, 7
	or	eax, ecx
	mov	eax, DWORD PTR _databitlen$[ebp+4]
	lea	edi, DWORD PTR [ebx+472]
	mov	ecx, edx
	jne	SHORT $LN2@Update
	shrd	ecx, eax, 3
	shr	eax, 3
	and	ecx, 63					; 0000003fH
; Line 310
	jmp	SHORT $LN32@Update
$LN2@Update:
; Line 311
	shrd	ecx, eax, 3
	and	ecx, 63					; 0000003fH
	shr	eax, 3
	inc	ecx
$LN32@Update:
	add	esi, DWORD PTR _data$[ebp]
; Line 312
	mov	eax, DWORD PTR _databitlen$[ebp+4]
	rep movsb
	mov	DWORD PTR [ebx+16], edx
	mov	DWORD PTR [ebx+20], eax
$LN3@Update:
; Line 315
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
; Line 316
	leave
	ret	0
_Update	ENDP
_TEXT	ENDS
PUBLIC	_Final
; Function compile flags: /Ogspy
;	COMDAT _Final
_TEXT	SEGMENT
_state$ = 8						; size = 4
_hashval$ = 12						; size = 4
_Final	PROC						; COMDAT
; Line 321
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
; Line 324
	mov	esi, DWORD PTR _state$[ebp]
	mov	edx, DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi+12]
	push	edi
	mov	ecx, edx
	and	ecx, 511				; 000001ffH
	xor	edi, edi
	or	ecx, edi
	mov	ebx, 128				; 00000080H
; Line 327
	push	64					; 00000040H
	jne	SHORT $LN10@Final
	xor	al, al
	pop	ecx
	lea	edi, DWORD PTR [esi+472]
	rep stosb
; Line 330
	mov	al, BYTE PTR [esi+8]
	mov	BYTE PTR [esi+535], al
; Line 331
	mov	al, BYTE PTR [esi+9]
	mov	BYTE PTR [esi+534], al
; Line 332
	mov	al, BYTE PTR [esi+10]
	mov	BYTE PTR [esi+533], al
; Line 333
	mov	al, BYTE PTR [esi+11]
	mov	BYTE PTR [esi+532], al
; Line 334
	mov	al, BYTE PTR [esi+12]
	mov	BYTE PTR [esi+531], al
; Line 335
	mov	al, BYTE PTR [esi+13]
	mov	BYTE PTR [esi+530], al
; Line 336
	mov	al, BYTE PTR [esi+14]
	mov	BYTE PTR [esi+529], al
; Line 337
	mov	al, BYTE PTR [esi+15]
; Line 338
	push	esi
	mov	BYTE PTR [esi+472], bl
	mov	BYTE PTR [esi+528], al
	call	_F8
; Line 340
	jmp	$LN13@Final
$LN10@Final:
; Line 342
	mov	ecx, DWORD PTR [esi+16]
; Line 343
	shrd	edx, eax, 3
	and	ecx, 7
	shr	eax, 3
	xor	edi, edi
	or	ecx, edi
	mov	ecx, eax
	mov	eax, edx
; Line 344
	pop	ecx
	jne	SHORT $LN8@Final
; Line 343
	and	eax, 63					; 0000003fH
; Line 347
	jmp	SHORT $LN14@Final
$LN8@Final:
; Line 348
	and	eax, 63					; 0000003fH
	inc	eax
$LN14@Final:
; Line 349
	movzx	edi, BYTE PTR [eax+esi+472]
	sub	ecx, eax
	xor	al, al
	rep stosb
; Line 354
	mov	eax, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi+8]
	shrd	eax, ecx, 3
	shr	ecx, 3
	push	7
	pop	ecx
	and	edx, ecx
	sub	ecx, edx
	mov	dl, 1
	shl	dl, cl
	and	eax, 63					; 0000003fH
	lea	eax, DWORD PTR [eax+esi+472]
; Line 355
	push	esi
	or	BYTE PTR [eax], dl
	call	_F8
; Line 357
	xor	al, al
	push	64					; 00000040H
	pop	ecx
	lea	edi, DWORD PTR [esi+472]
	rep stosb
; Line 360
	mov	al, BYTE PTR [esi+8]
	mov	BYTE PTR [esi+535], al
; Line 361
	mov	al, BYTE PTR [esi+9]
	mov	BYTE PTR [esi+534], al
; Line 362
	mov	al, BYTE PTR [esi+10]
	mov	BYTE PTR [esi+533], al
; Line 363
	mov	al, BYTE PTR [esi+11]
	mov	BYTE PTR [esi+532], al
; Line 364
	mov	al, BYTE PTR [esi+12]
	mov	BYTE PTR [esi+531], al
; Line 365
	mov	al, BYTE PTR [esi+13]
	mov	BYTE PTR [esi+530], al
; Line 366
	mov	al, BYTE PTR [esi+14]
	mov	BYTE PTR [esi+529], al
; Line 367
	mov	al, BYTE PTR [esi+15]
; Line 368
	push	esi
	mov	BYTE PTR [esi+528], al
	call	_F8
	pop	ecx
$LN13@Final:
; Line 372
	mov	eax, DWORD PTR [esi]
	sub	eax, 224				; 000000e0H
	pop	ecx
	je	SHORT $LN4@Final
	push	32					; 00000020H
	pop	ecx
	sub	eax, ecx
	je	SHORT $LN3@Final
	sub	eax, ebx
	je	SHORT $LN2@Final
	sub	eax, ebx
	jne	SHORT $LN5@Final
; Line 376
	add	esi, 88					; 00000058H
	push	64					; 00000040H
	jmp	SHORT $LN15@Final
$LN2@Final:
; Line 375
	add	esi, 104				; 00000068H
	push	48					; 00000030H
	jmp	SHORT $LN15@Final
$LN3@Final:
; Line 374
	add	esi, 120				; 00000078H
	jmp	SHORT $LN16@Final
$LN4@Final:
; Line 373
	add	esi, 124				; 0000007cH
	push	28					; 0000001cH
$LN15@Final:
	pop	ecx
$LN16@Final:
	mov	edi, DWORD PTR _hashval$[ebp]
	rep movsb
$LN5@Final:
; Line 379
	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebx
; Line 380
	pop	ebp
	ret	0
_Final	ENDP
_TEXT	ENDS
PUBLIC	_Hash
; Function compile flags: /Ogspy
;	COMDAT _Hash
_TEXT	SEGMENT
_state$ = -536						; size = 536
_hashbitlen$ = 8					; size = 4
_data$ = 12						; size = 4
_databitlen$ = 16					; size = 8
_hashval$ = 24						; size = 4
_Hash	PROC						; COMDAT
; Line 388
	push	ebp
	mov	ebp, esp
; Line 391
	mov	eax, DWORD PTR _hashbitlen$[ebp]
	sub	esp, 536				; 00000218H
	cmp	eax, 224				; 000000e0H
	je	SHORT $LN2@Hash
	cmp	eax, 256				; 00000100H
	je	SHORT $LN2@Hash
	cmp	eax, 384				; 00000180H
	je	SHORT $LN2@Hash
	cmp	eax, 512				; 00000200H
	je	SHORT $LN2@Hash
; Line 398
	push	2
	pop	eax
; Line 399
	leave
	ret	0
$LN2@Hash:
; Line 392
	push	eax
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_Init
; Line 393
	push	DWORD PTR _databitlen$[ebp+4]
	lea	eax, DWORD PTR _state$[ebp]
	push	DWORD PTR _databitlen$[ebp]
	push	DWORD PTR _data$[ebp]
	push	eax
	call	_Update
; Line 394
	push	DWORD PTR _hashval$[ebp]
	lea	eax, DWORD PTR _state$[ebp]
	push	eax
	call	_Final
	add	esp, 32					; 00000020H
; Line 395
	xor	eax, eax
; Line 399
	leave
	ret	0
_Hash	ENDP
_TEXT	ENDS
END
