; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\odzhan\tinycrypt\aead\poly1305\poly1305.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_add
; Function compile flags: /Ogspy
;	COMDAT _add
_TEXT	SEGMENT
_h$ = 8							; size = 4
_c$ = 12						; size = 4
_add	PROC						; COMDAT
; File c:\odzhan\tinycrypt\aead\poly1305\poly1305.c
; Line 41
	mov	eax, DWORD PTR _h$[esp-4]
; Line 43
	mov	ecx, DWORD PTR _c$[esp-4]
	push	esi
	push	edi
	push	17					; 00000011H
	xor	edx, edx
	sub	ecx, eax
	pop	esi
$LL3@add:
; Line 44
	mov	edi, DWORD PTR [ecx+eax]
	add	edi, DWORD PTR [eax]
	add	edx, edi
; Line 45
	movzx	edi, dl
	mov	DWORD PTR [eax], edi
; Line 46
	shr	edx, 8
	add	eax, 4
	dec	esi
	jne	SHORT $LL3@add
; Line 48
	pop	edi
	pop	esi
	ret	0
_add	ENDP
_TEXT	ENDS
PUBLIC	_freeze
; Function compile flags: /Ogspy
;	COMDAT _freeze
_TEXT	SEGMENT
_horig$ = -136						; size = 68
_minusp$ = -68						; size = 68
_x$ = 8							; size = 4
_freeze	PROC						; COMDAT
; Line 51
	push	ebp
	mov	ebp, esp
	sub	esp, 136				; 00000088H
	push	ebx
; Line 60
	mov	ebx, DWORD PTR _x$[ebp]
	push	esi
	push	edi
	push	68					; 00000044H
	pop	ecx
	xor	al, al
	push	68					; 00000044H
	lea	edi, DWORD PTR _minusp$[ebp]
	rep stosb
	pop	ecx
; Line 62
	lea	eax, DWORD PTR _minusp$[ebp]
	push	eax
	lea	edi, DWORD PTR _horig$[ebp]
	mov	esi, ebx
	push	ebx
	mov	DWORD PTR _minusp$[ebp], 5
	mov	DWORD PTR _minusp$[ebp+64], 252		; 000000fcH
	rep movsb
	call	_add
; Line 63
	mov	eax, DWORD PTR [ebx+64]
	pop	ecx
	pop	ecx
	shr	eax, 7
; Line 65
	lea	edx, DWORD PTR _horig$[ebp]
	push	17					; 00000011H
	neg	eax
	mov	ecx, ebx
	sub	edx, ebx
	pop	edi
$LL3@freeze:
; Line 66
	mov	esi, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [edx+ecx]
	xor	ebx, esi
	and	ebx, eax
	xor	ebx, esi
	mov	DWORD PTR [ecx], ebx
	add	ecx, 4
	dec	edi
	jne	SHORT $LL3@freeze
	pop	edi
	pop	esi
	pop	ebx
; Line 68
	leave
	ret	0
_freeze	ENDP
_TEXT	ENDS
PUBLIC	_squeeze
; Function compile flags: /Ogspy
;	COMDAT _squeeze
_TEXT	SEGMENT
_x$ = 8							; size = 4
_squeeze PROC						; COMDAT
; Line 75
	mov	ecx, DWORD PTR _x$[esp-4]
	xor	eax, eax
	xor	edx, edx
	push	esi
$LL6@squeeze:
; Line 76
	add	eax, DWORD PTR [ecx+edx*4]
; Line 77
	movzx	esi, al
; Line 78
	shr	eax, 8
	mov	DWORD PTR [ecx+edx*4], esi
	inc	edx
	cmp	edx, 16					; 00000010H
	jb	SHORT $LL6@squeeze
; Line 81
	add	eax, DWORD PTR [ecx+64]
; Line 82
	mov	edx, eax
	and	edx, 3
; Line 83
	shr	eax, 2
	mov	DWORD PTR [ecx+64], edx
	imul	eax, 5
; Line 85
	xor	edx, edx
$LL3@squeeze:
; Line 86
	add	eax, DWORD PTR [ecx+edx*4]
; Line 87
	movzx	esi, al
; Line 88
	shr	eax, 8
	mov	DWORD PTR [ecx+edx*4], esi
	inc	edx
	cmp	edx, 16					; 00000010H
	jb	SHORT $LL3@squeeze
; Line 90
	add	DWORD PTR [ecx+64], eax
	pop	esi
; Line 91
	ret	0
_squeeze ENDP
_TEXT	ENDS
PUBLIC	_mulmod
; Function compile flags: /Ogspy
;	COMDAT _mulmod
_TEXT	SEGMENT
_hr$ = -72						; size = 68
tv468 = -4						; size = 4
_h$ = 8							; size = 4
_r$ = 12						; size = 4
_mulmod	PROC						; COMDAT
; Line 95
	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
; Line 99
	mov	ecx, DWORD PTR _r$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _h$[ebp]
	lea	eax, DWORD PTR _hr$[ebp]
	xor	edx, edx
	push	esi
	sub	ecx, eax
	push	edi
	mov	DWORD PTR tv468[ebp], ecx
	jmp	SHORT $LN9@mulmod
$LL18@mulmod:
	mov	ecx, DWORD PTR tv468[ebp]
$LN9@mulmod:
	lea	ecx, DWORD PTR [ecx+edx*4]
; Line 100
	xor	esi, esi
; Line 101
	xor	eax, eax
	lea	ecx, DWORD PTR _hr$[ebp+ecx]
$LL6@mulmod:
; Line 102
	mov	edi, DWORD PTR [ebx+eax*4]
	imul	edi, DWORD PTR [ecx]
	add	esi, edi
	inc	eax
	sub	ecx, 4
	cmp	eax, edx
	jbe	SHORT $LL6@mulmod
; Line 104
	cmp	eax, 17					; 00000011H
	jae	SHORT $LN1@mulmod
	mov	edi, DWORD PTR _r$[ebp]
	mov	ecx, edx
	sub	ecx, eax
	lea	ecx, DWORD PTR [edi+ecx*4+68]
$LL3@mulmod:
; Line 105
	mov	edi, DWORD PTR [ebx+eax*4]
	imul	edi, DWORD PTR [ecx]
	imul	edi, 320				; 00000140H
	add	esi, edi
	inc	eax
	sub	ecx, 4
	cmp	eax, 17					; 00000011H
	jb	SHORT $LL3@mulmod
$LN1@mulmod:
; Line 107
	mov	DWORD PTR _hr$[ebp+edx*4], esi
	inc	edx
	cmp	edx, 17					; 00000011H
	jb	SHORT $LL18@mulmod
; Line 109
	push	68					; 00000044H
	pop	ecx
	lea	esi, DWORD PTR _hr$[ebp]
	mov	edi, ebx
; Line 110
	push	ebx
	rep movsb
	call	_squeeze
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
; Line 111
	leave
	ret	0
_mulmod	ENDP
_TEXT	ENDS
PUBLIC	_poly1305_mac
; Function compile flags: /Ogspy
;	COMDAT _poly1305_mac
_TEXT	SEGMENT
_acc$ = -100						; size = 68
_block$ = -32						; size = 68
_r$ = 36						; size = 68
_out$ = 112						; size = 4
_in$ = 116						; size = 4
_inlen$ = 120						; size = 4
_k$ = 124						; size = 4
_poly1305_mac PROC					; COMDAT
; Line 120
	push	ebp
	lea	ebp, DWORD PTR [esp-104]
	sub	esp, 204				; 000000ccH
; Line 125
	xor	eax, eax
$LL14@poly1305_m:
; Line 126
	mov	ecx, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [eax+ecx]
	mov	DWORD PTR _r$[ebp+eax*4], ecx
	inc	eax
	cmp	eax, 16					; 00000010H
	jb	SHORT $LL14@poly1305_m
; Line 137
	and	DWORD PTR _r$[ebp+64], 0
	push	ebx
; Line 142
	mov	ebx, DWORD PTR _inlen$[ebp]
	push	edi
	push	15					; 0000000fH
	pop	eax
	and	DWORD PTR _r$[ebp+12], eax
	and	DWORD PTR _r$[ebp+28], eax
	and	DWORD PTR _r$[ebp+44], eax
	and	DWORD PTR _r$[ebp+60], eax
	mov	eax, 252				; 000000fcH
	and	DWORD PTR _r$[ebp+16], eax
	and	DWORD PTR _r$[ebp+32], eax
	and	DWORD PTR _r$[ebp+48], eax
	push	68					; 00000044H
	xor	al, al
	lea	edi, DWORD PTR _acc$[ebp]
	pop	ecx
	rep stosb
	test	ebx, ebx
	je	SHORT $LN30@poly1305_m
	push	esi
$LL11@poly1305_m:
; Line 144
	push	68					; 00000044H
	pop	ecx
; Line 147
	push	16					; 00000010H
	xor	al, al
	pop	esi
	lea	edi, DWORD PTR _block$[ebp]
	rep stosb
	cmp	ebx, esi
	jae	SHORT $LN17@poly1305_m
	mov	esi, ebx
$LN17@poly1305_m:
; Line 153
	xor	eax, eax
	mov	DWORD PTR _block$[ebp+esi*4], 1
	test	esi, esi
	je	SHORT $LN7@poly1305_m
$LL9@poly1305_m:
; Line 154
	mov	ecx, DWORD PTR _in$[ebp]
	movzx	ecx, BYTE PTR [eax+ecx]
	mov	DWORD PTR _block$[ebp+eax*4], ecx
	inc	eax
	cmp	eax, esi
	jb	SHORT $LL9@poly1305_m
$LN7@poly1305_m:
; Line 158
	lea	eax, DWORD PTR _block$[ebp]
	push	eax
	lea	eax, DWORD PTR _acc$[ebp]
	push	eax
	call	_add
; Line 161
	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	lea	eax, DWORD PTR _acc$[ebp]
	push	eax
	call	_mulmod
; Line 164
	add	DWORD PTR _in$[ebp], esi
	add	esp, 16					; 00000010H
; Line 165
	sub	ebx, esi
	jne	SHORT $LL11@poly1305_m
	pop	esi
$LN30@poly1305_m:
; Line 168
	lea	eax, DWORD PTR _acc$[ebp]
	push	eax
	call	_freeze
	pop	ecx
	pop	edi
; Line 171
	xor	eax, eax
	pop	ebx
$LL6@poly1305_m:
; Line 172
	mov	ecx, DWORD PTR _k$[ebp]
	movzx	ecx, BYTE PTR [ecx+eax+16]
	mov	DWORD PTR _block$[ebp+eax*4], ecx
	inc	eax
	cmp	eax, 16					; 00000010H
	jb	SHORT $LL6@poly1305_m
; Line 175
	and	DWORD PTR _block$[ebp+64], 0
; Line 176
	lea	eax, DWORD PTR _block$[ebp]
	push	eax
	lea	eax, DWORD PTR _acc$[ebp]
	push	eax
	call	_add
	pop	ecx
	pop	ecx
; Line 179
	xor	eax, eax
$LL3@poly1305_m:
; Line 180
	mov	cl, BYTE PTR _acc$[ebp+eax*4]
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+edx], cl
	inc	eax
	cmp	eax, 16					; 00000010H
	jb	SHORT $LL3@poly1305_m
; Line 182
	add	ebp, 104				; 00000068H
	leave
	ret	0
_poly1305_mac ENDP
_TEXT	ENDS
END
