; Listing generated by Microsoft (R) Optimizing Compiler Version 16.00.40219.01 

	TITLE	C:\odzhan\tinycrypt\aead\poly1305\auth.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
_minusp	DD	05H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	0fcH
; Function compile flags: /Ogspy
CONST	ENDS
;	COMDAT _add
_TEXT	SEGMENT
_add	PROC						; COMDAT
; _h$ = eax
; _c$ = ecx
; File c:\odzhan\tinycrypt\aead\poly1305\auth.c
; Line 15
	push	esi
	push	edi
; Line 18
	push	17					; 00000011H
	xor	edx, edx
; Line 20
	sub	ecx, eax
	pop	esi
$LL3@add:
; Line 21
	mov	edi, DWORD PTR [ecx+eax]
	add	edi, DWORD PTR [eax]
	add	edx, edi
; Line 22
	movzx	edi, dl
	mov	DWORD PTR [eax], edi
; Line 23
	shr	edx, 8
	add	eax, 4
	dec	esi
	jne	SHORT $LL3@add
; Line 25
	pop	edi
	pop	esi
	ret	0
_add	ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT _squeeze
_TEXT	SEGMENT
_squeeze PROC						; COMDAT
; _h$ = ecx
; Line 31
	xor	eax, eax
; Line 32
	xor	edx, edx
	push	esi
$LL6@squeeze:
; Line 33
	add	eax, DWORD PTR [ecx+edx*4]
; Line 34
	movzx	esi, al
; Line 35
	shr	eax, 8
	mov	DWORD PTR [ecx+edx*4], esi
	inc	edx
	cmp	edx, 16					; 00000010H
	jb	SHORT $LL6@squeeze
; Line 37
	add	eax, DWORD PTR [ecx+64]
; Line 38
	mov	edx, eax
	and	edx, 3
; Line 39
	shr	eax, 2
	mov	DWORD PTR [ecx+64], edx
	imul	eax, 5
; Line 41
	xor	edx, edx
$LL3@squeeze:
; Line 42
	add	eax, DWORD PTR [ecx+edx*4]
; Line 43
	movzx	esi, al
; Line 44
	shr	eax, 8
	mov	DWORD PTR [ecx+edx*4], esi
	inc	edx
	cmp	edx, 16					; 00000010H
	jb	SHORT $LL3@squeeze
; Line 47
	add	DWORD PTR [ecx+64], eax
	pop	esi
; Line 48
	ret	0
_squeeze ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT _freeze
_TEXT	SEGMENT
_horig$ = -68						; size = 68
_freeze	PROC						; COMDAT
; _h$ = eax
; Line 55
	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	push	ebx
	push	esi
	push	edi
	mov	ebx, eax
; Line 59
	push	68					; 00000044H
	pop	ecx
	lea	edi, DWORD PTR _horig$[ebp]
	mov	esi, ebx
	rep movsb
; Line 63
	mov	ecx, OFFSET _minusp
	call	_add
; Line 64
	mov	ecx, DWORD PTR [ebx+64]
	shr	ecx, 7
; Line 66
	lea	edx, DWORD PTR _horig$[ebp]
	push	17					; 00000011H
	neg	ecx
	mov	eax, ebx
	sub	edx, ebx
	pop	edi
$LL3@freeze:
; Line 67
	mov	esi, DWORD PTR [eax]
	mov	ebx, DWORD PTR [edx+eax]
	xor	ebx, esi
	and	ebx, ecx
	xor	ebx, esi
	mov	DWORD PTR [eax], ebx
	add	eax, 4
	dec	edi
	jne	SHORT $LL3@freeze
	pop	edi
	pop	esi
	pop	ebx
; Line 68
	leave
	ret	0
_freeze	ENDP
; Function compile flags: /Ogspy
_TEXT	ENDS
;	COMDAT _mulmod
_TEXT	SEGMENT
_hr$ = -76						; size = 68
tv250 = -8						; size = 4
tv547 = -4						; size = 4
_r$ = 8							; size = 4
_mulmod	PROC						; COMDAT
; _h$ = edx
; Line 72
	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi
; Line 76
	mov	edi, DWORD PTR _r$[ebp]
	lea	ecx, DWORD PTR _hr$[ebp]
	xor	eax, eax
	sub	edi, ecx
	mov	DWORD PTR tv547[ebp], edi
	jmp	SHORT $LN9@mulmod
$LL30@mulmod:
	mov	edi, DWORD PTR tv547[ebp]
$LN9@mulmod:
	mov	ecx, eax
	shl	ecx, 2
	mov	DWORD PTR tv250[ebp], ecx
; Line 77
	xor	ebx, ebx
; Line 78
	xor	esi, esi
	add	ecx, edi
	lea	ecx, DWORD PTR _hr$[ebp+ecx]
$LL6@mulmod:
; Line 79
	mov	edi, DWORD PTR [edx+esi*4]
	imul	edi, DWORD PTR [ecx]
	add	ebx, edi
	inc	esi
	sub	ecx, 4
	cmp	esi, eax
	jbe	SHORT $LL6@mulmod
; Line 81
	lea	esi, DWORD PTR [eax+1]
	mov	ecx, esi
	cmp	esi, 17					; 00000011H
	jae	SHORT $LN1@mulmod
	mov	edi, DWORD PTR _r$[ebp]
	sub	eax, esi
	lea	eax, DWORD PTR [edi+eax*4+68]
$LL3@mulmod:
; Line 82
	mov	edi, DWORD PTR [edx+ecx*4]
	imul	edi, DWORD PTR [eax]
	imul	edi, 320				; 00000140H
	add	ebx, edi
	inc	ecx
	sub	eax, 4
	cmp	ecx, 17					; 00000011H
	jb	SHORT $LL3@mulmod
$LN1@mulmod:
; Line 84
	mov	eax, DWORD PTR tv250[ebp]
	mov	DWORD PTR _hr$[ebp+eax], ebx
	mov	eax, esi
	cmp	eax, 17					; 00000011H
	jb	SHORT $LL30@mulmod
; Line 86
	push	68					; 00000044H
	lea	esi, DWORD PTR _hr$[ebp]
	mov	edi, edx
	pop	ecx
	rep movsb
; Line 90
	xor	eax, eax
	xor	ecx, ecx
$LL17@mulmod:
	add	eax, DWORD PTR [edx+ecx*4]
	movzx	esi, al
	shr	eax, 8
	mov	DWORD PTR [edx+ecx*4], esi
	inc	ecx
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LL17@mulmod
	add	eax, DWORD PTR [edx+64]
	mov	ecx, eax
	and	ecx, 3
	shr	eax, 2
	mov	DWORD PTR [edx+64], ecx
	imul	eax, 5
	xor	ecx, ecx
$LL14@mulmod:
	add	eax, DWORD PTR [edx+ecx*4]
	movzx	esi, al
	shr	eax, 8
	mov	DWORD PTR [edx+ecx*4], esi
	inc	ecx
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LL14@mulmod
	add	DWORD PTR [edx+64], eax
	pop	edi
	pop	esi
	pop	ebx
; Line 91
	leave
	ret	0
_mulmod	ENDP
_TEXT	ENDS
PUBLIC	_ota
; Function compile flags: /Ogspy
;	COMDAT _ota
_TEXT	SEGMENT
_c$ = -104						; size = 68
_h$ = -36						; size = 68
_horig$4197 = 32					; size = 68
_r$ = 32						; size = 68
_out$ = 108						; size = 4
_in$ = 112						; size = 4
_inlen$ = 116						; size = 8
_k$ = 124						; size = 4
_ota	PROC						; COMDAT
; Line 95
	push	ebp
	lea	ebp, DWORD PTR [esp-100]
	sub	esp, 204				; 000000ccH
	push	ebx
; Line 100
	mov	ebx, DWORD PTR _k$[ebp]
	movzx	eax, BYTE PTR [ebx]
; Line 104
	movzx	edx, BYTE PTR [ebx+4]
	mov	DWORD PTR _r$[ebp], eax
	movzx	eax, BYTE PTR [ebx+1]
	mov	DWORD PTR _r$[ebp+4], eax
	movzx	eax, BYTE PTR [ebx+2]
	push	esi
	mov	DWORD PTR _r$[ebp+8], eax
	movzx	eax, BYTE PTR [ebx+3]
	push	edi
	push	15					; 0000000fH
	pop	ecx
	and	eax, ecx
	mov	DWORD PTR _r$[ebp+12], eax
	mov	eax, 252				; 000000fcH
	and	edx, eax
	mov	DWORD PTR _r$[ebp+16], edx
; Line 105
	movzx	edx, BYTE PTR [ebx+5]
	mov	DWORD PTR _r$[ebp+20], edx
; Line 106
	movzx	edx, BYTE PTR [ebx+6]
	mov	DWORD PTR _r$[ebp+24], edx
; Line 107
	movzx	edx, BYTE PTR [ebx+7]
	and	edx, ecx
	mov	DWORD PTR _r$[ebp+28], edx
; Line 108
	movzx	edx, BYTE PTR [ebx+8]
	and	edx, eax
	mov	DWORD PTR _r$[ebp+32], edx
; Line 109
	movzx	edx, BYTE PTR [ebx+9]
	mov	DWORD PTR _r$[ebp+36], edx
; Line 110
	movzx	edx, BYTE PTR [ebx+10]
	mov	DWORD PTR _r$[ebp+40], edx
; Line 111
	movzx	edx, BYTE PTR [ebx+11]
; Line 123
	mov	esi, DWORD PTR _inlen$[ebp+4]
	and	DWORD PTR _r$[ebp+64], 0
	and	edx, ecx
	mov	DWORD PTR _r$[ebp+44], edx
	movzx	edx, BYTE PTR [ebx+12]
	and	edx, eax
	movzx	eax, BYTE PTR [ebx+13]
	mov	DWORD PTR _r$[ebp+52], eax
	movzx	eax, BYTE PTR [ebx+14]
	mov	DWORD PTR _r$[ebp+56], eax
	movzx	eax, BYTE PTR [ebx+15]
	and	eax, ecx
	push	68					; 00000044H
	mov	DWORD PTR _r$[ebp+60], eax
	xor	al, al
	lea	edi, DWORD PTR _h$[ebp]
	pop	ecx
	mov	DWORD PTR _r$[ebp+48], edx
	rep stosb
	test	esi, esi
	je	SHORT $LN47@ota
$LL11@ota:
; Line 125
	push	68					; 00000044H
	xor	al, al
	lea	edi, DWORD PTR _c$[ebp]
	pop	ecx
	rep stosb
; Line 133
	xor	edi, edi
$LL9@ota:
	xor	eax, eax
	cmp	eax, esi
	ja	SHORT $LN7@ota
	jb	SHORT $LN32@ota
	cmp	edi, DWORD PTR _inlen$[ebp]
	jae	SHORT $LN7@ota
$LN32@ota:
; Line 134
	mov	eax, DWORD PTR _in$[ebp]
	movzx	eax, BYTE PTR [edi+eax]
	mov	DWORD PTR _c$[ebp+edi*4], eax
	inc	edi
	cmp	edi, 16					; 00000010H
	jb	SHORT $LL9@ota
$LN7@ota:
; Line 140
	lea	ecx, DWORD PTR _c$[ebp]
	lea	eax, DWORD PTR _h$[ebp]
	mov	DWORD PTR _c$[ebp+edi*4], 1
	call	_add
; Line 142
	lea	eax, DWORD PTR _r$[ebp]
	push	eax
	lea	edx, DWORD PTR _h$[ebp]
	call	_mulmod
; Line 145
	add	DWORD PTR _in$[ebp], edi
; Line 146
	sub	DWORD PTR _inlen$[ebp], edi
	pop	ecx
	sbb	esi, 0
	test	esi, esi
	ja	SHORT $LL11@ota
; Line 123
	jb	SHORT $LN40@ota
$LN47@ota:
	cmp	DWORD PTR _inlen$[ebp], 0
	ja	SHORT $LL11@ota
$LN40@ota:
; Line 149
	push	68					; 00000044H
	pop	ecx
	lea	esi, DWORD PTR _h$[ebp]
	lea	edi, DWORD PTR _horig$4197[ebp]
	rep movsb
	mov	ecx, OFFSET _minusp
	lea	eax, DWORD PTR _h$[ebp]
	call	_add
	mov	ecx, DWORD PTR _h$[ebp+64]
	shr	ecx, 7
	neg	ecx
	xor	edx, edx
$LL18@ota:
	mov	edi, DWORD PTR _horig$4197[ebp+edx]
	lea	eax, DWORD PTR _h$[ebp+edx]
	mov	esi, DWORD PTR [eax]
	xor	edi, esi
	and	edi, ecx
	xor	edi, esi
	add	edx, 4
	mov	DWORD PTR [eax], edi
	cmp	edx, 68					; 00000044H
	jb	SHORT $LL18@ota
; Line 153
	xor	eax, eax
$LL6@ota:
; Line 154
	movzx	ecx, BYTE PTR [ebx+eax+16]
	mov	DWORD PTR _c$[ebp+eax*4], ecx
	inc	eax
	cmp	eax, 16					; 00000010H
	jb	SHORT $LL6@ota
; Line 156
	and	DWORD PTR _c$[ebp+64], 0
; Line 157
	lea	ecx, DWORD PTR _c$[ebp]
	lea	eax, DWORD PTR _h$[ebp]
	call	_add
	pop	edi
	pop	esi
; Line 160
	xor	eax, eax
	pop	ebx
$LL3@ota:
; Line 161
	mov	cl, BYTE PTR _h$[ebp+eax*4]
	mov	edx, DWORD PTR _out$[ebp]
	mov	BYTE PTR [eax+edx], cl
	inc	eax
	cmp	eax, 16					; 00000010H
	jb	SHORT $LL3@ota
; Line 163
	xor	eax, eax
; Line 164
	add	ebp, 100				; 00000064H
	leave
	ret	0
_ota	ENDP
_TEXT	ENDS
END
