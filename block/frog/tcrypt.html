<!-- 29/03/00 --><HTML>
<!-- Mirrored from www.tecapro.com/aesfrog.html by HTTrack Website Copier/3.x [XR&CO'2004], Sat, 27 Nov 2004 22:44:55 GMT -->
<HEAD>


<script type="text/javascript" src="/static/js/analytics.js"></script>
<script type="text/javascript">archive_analytics.values.server_name="wwwb-app10.us.archive.org";archive_analytics.values.server_ms=2203;</script>
<link type="text/css" rel="stylesheet" href="/static/css/banner-styles.css"/>

<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML; CHARSET=WINDOWS-1252"><META NAME="GENERATOR" CONTENT="MICROSOFT WORD 97"><TITLE>SPECIFICATION OF THE ALGORITHM </TITLE><!--10011440014--><title>TecApro - Recursos - Art&iacute;culos, ensayos, ponencias</title><meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"><META NAME="description" CONTENT="Productos gratuitos, art&iacute;culos, artes TecApro, fuentes"><META NAME="keywords" CONTENT="articulos, tecapro, documentos, informes, frog, godsave, encripcion, encripci&oacute;n, algoritmo, algorithm"></head><body bgcolor="White" vlink="Blue">


<!-- BEGIN WAYBACK TOOLBAR INSERT -->
<script type="text/javascript" src="/static/js/disclaim-element.js" ></script>
<script type="text/javascript" src="/static/js/graph-calc.js" ></script>
<script type="text/javascript">//<![CDATA[
var __wm = (function(imgWidth,imgHeight,yearImgWidth,monthImgWidth){
var wbPrefix = "/web/";
var wbCurrentUrl = "http://tecapro.com/aesfrog.html";

var firstYear = 1996;
var displayDay = "30";
var displayMonth = "Oct";
var displayYear = "2005";
var prettyMonths = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
var $D=document,$=function(n){return document.getElementById(n)};
var trackerVal,curYear = -1,curMonth = -1;
var yearTracker,monthTracker;
function showTrackers(val) {
  if (val===trackerVal) return;
  var $ipp=$("wm-ipp");
  var $y=$("displayYearEl"),$m=$("displayMonthEl"),$d=$("displayDayEl");
  if (val) {
    $ipp.className="hi";
  } else {
    $ipp.className="";
    $y.innerHTML=displayYear;$m.innerHTML=displayMonth;$d.innerHTML=displayDay;
  }
  yearTracker.style.display=val?"inline":"none";
  monthTracker.style.display=val?"inline":"none";
  trackerVal = val;
}
function trackMouseMove(event,element) {
  var eventX = getEventX(event);
  var elementX = getElementX(element);
  var xOff = Math.min(Math.max(0, eventX - elementX),imgWidth);
  var monthOff = xOff % yearImgWidth;

  var year = Math.floor(xOff / yearImgWidth);
  var monthOfYear = Math.min(11,Math.floor(monthOff / monthImgWidth));
  // 1 extra border pixel at the left edge of the year:
  var month = (year * 12) + monthOfYear;
  var day = monthOff % 2==1?15:1;
  var dateString = zeroPad(year + firstYear) + zeroPad(monthOfYear+1,2) +
    zeroPad(day,2) + "000000";

  $("displayYearEl").innerHTML=year+firstYear;
  $("displayMonthEl").innerHTML=prettyMonths[monthOfYear];
  // looks too jarring when it changes..
  //$("displayDayEl").innerHTML=zeroPad(day,2);
  var url = wbPrefix + dateString + '/' +  wbCurrentUrl;
  $("wm-graph-anchor").href=url;

  if(curYear != year) {
    var yrOff = year * yearImgWidth;
    yearTracker.style.left = yrOff + "px";
    curYear = year;
  }
  if(curMonth != month) {
    var mtOff = year + (month * monthImgWidth) + 1;
    monthTracker.style.left = mtOff + "px";
    curMonth = month;
  }
}
function hideToolbar() {
  $("wm-ipp").style.display="none";
}
function bootstrap() {
  var $spk=$("wm-ipp-sparkline");
  yearTracker=$D.createElement('div');
  yearTracker.className='yt';
  with(yearTracker.style){
    display='none';width=yearImgWidth+"px";height=imgHeight+"px";
  }
  monthTracker=$D.createElement('div');
  monthTracker.className='mt';
  with(monthTracker.style){
    display='none';width=monthImgWidth+"px";height=imgHeight+"px";
  }
  $spk.appendChild(yearTracker);
  $spk.appendChild(monthTracker);

  var $ipp=$("wm-ipp");
  $ipp&&disclaimElement($ipp);
}
return{st:showTrackers,mv:trackMouseMove,h:hideToolbar,bt:bootstrap};
})(550, 27, 25, 2);//]]>
</script>
<style type="text/css">
body {
  margin-top:0 !important;
  padding-top:0 !important;
  min-width:800px !important;
}
</style>
<div id="wm-ipp" lang="en" style="display:none;">

<div style="position:fixed;left:0;top:0;width:100%!important">
<div id="wm-ipp-inside">
   <table style="width:100%;"><tbody><tr>
   <td id="wm-logo">
       <a href="/web/" title="Wayback Machine home page"><img src="/static/images/toolbar/wayback-toolbar-logo.png" alt="Wayback Machine" width="110" height="39" border="0" /></a>
   </td>
   <td class="c">
       <table style="margin:0 auto;"><tbody><tr>
       <td class="u" colspan="2">
       <form target="_top" method="get" action="/web/form-submit.jsp" name="wmtb" id="wmtb"><input type="text" name="url" id="wmtbURL" value="http://tecapro.com/aesfrog.html" style="width:400px;" onfocus="this.focus();this.select();" /><input type="hidden" name="type" value="replay" /><input type="hidden" name="date" value="20051030164234" /><input type="submit" value="Go" /><span id="wm_tb_options" style="display:block;"></span></form>
       </td>
       <td class="n" rowspan="2">
           <table><tbody>
           <!-- NEXT/PREV MONTH NAV AND MONTH INDICATOR -->
           <tr class="m">
           	<td class="b" nowrap="nowrap">
		
		    <a href="/web/20050911033951/http://www.tecapro.com/aesfrog.html" title="11 Sep 2005">SEP</a>
		
		</td>
		<td class="c" id="displayMonthEl" title="You are here: 16:42:34 Oct 30, 2005">OCT</td>
		<td class="f" nowrap="nowrap">
		
		    <a href="/web/20060212215305/http://tecapro.com/aesfrog.html" title="12 Feb 2006"><strong>FEB</strong></a>
		
                </td>
	    </tr>
           <!-- NEXT/PREV CAPTURE NAV AND DAY OF MONTH INDICATOR -->
           <tr class="d">
               <td class="b" nowrap="nowrap">
               
                   <a href="/web/20050911033951/http://www.tecapro.com/aesfrog.html" title="3:39:51 Sep 11, 2005"><img src="/static/images/toolbar/wm_tb_prv_on.png" alt="Previous capture" width="14" height="16" border="0" /></a>
               
               </td>
               <td class="c" id="displayDayEl" style="width:34px;font-size:24px;" title="You are here: 16:42:34 Oct 30, 2005">30</td>
	       <td class="f" nowrap="nowrap">
               
		   <a href="/web/20060212215305/http://tecapro.com/aesfrog.html" title="21:53:05 Feb 12, 2006"><img src="/static/images/toolbar/wm_tb_nxt_on.png" alt="Next capture" width="14" height="16" border="0" /></a>
	       
	       </td>
           </tr>
           <!-- NEXT/PREV YEAR NAV AND YEAR INDICATOR -->
           <tr class="y">
	       <td class="b" nowrap="nowrap">
               
                   <a href="/web/20041016042818/http://www.tecapro.com/aesfrog.html" title="16 Oct 2004"><strong>2004</strong></a>
               
               </td>
               <td class="c" id="displayYearEl" title="You are here: 16:42:34 Oct 30, 2005">2005</td>
	       <td class="f" nowrap="nowrap">
               
	           <a href="/web/20070120111209/http://tecapro.com/aesfrog.html" title="20 Jan 2007"><strong>2007</strong></a>
	       
	       </td>
           </tr>
           </tbody></table>
       </td>
       </tr>
       <tr>
       <td class="s">
           <a class="t" href="/web/20051030164234*/http://tecapro.com/aesfrog.html" title="See a list of every capture for this URL">43 captures</a>
           <div class="r" title="Timespan for captures of this URL">12 Dec 00 - 9 Apr 16</div>
       </td>
       <td class="k">
       <a href="" id="wm-graph-anchor">
       <div id="wm-ipp-sparkline" title="Explore captures for this URL">
	 <img id="sparklineImgId" alt="sparklines"
		 onmouseover="__wm.st(1)" onmouseout="__wm.st(0)"
		 onmousemove="__wm.mv(event,this)"
		 width="550"
		 height="27"
		 border="0"
		 src="/web/jsp/graph.jsp?graphdata=550_27_1996:-1:000000000000_1997:-1:000000000000_1998:-1:000000000000_1999:-1:000000000000_2000:-1:000000000001_2001:-1:001100100000_2002:-1:000000010101_2003:-1:010100100101_2004:-1:010101010101_2005:9:011100002100_2006:-1:020020000000_2007:-1:101000001000_2008:-1:000000001000_2009:-1:000000000000_2010:-1:000000000000_2011:-1:001011110000_2012:-1:000100100000_2013:-1:000000000000_2014:-1:000000000002_2015:-1:000000000000_2016:-1:000200000000_2017:-1:000000000000" />
       </div>
       </a>
       </td>
       </tr></tbody></table>
   </td>
   <td class="r">
       <a href="#close" onclick="__wm.h();return false;" style="background-image:url(/static/images/toolbar/wm_tb_close.png);top:5px;" title="Close the toolbar">Close</a>
       <a href="http://faq.web.archive.org/" style="background-image:url(/static/images/toolbar/wm_tb_help.png);bottom:5px;" title="Get some help using the Wayback Machine">Help</a>
   </td>
   </tr></tbody></table>
</div>
</div>
</div>
<script type="text/javascript">__wm.bt();</script>
<!-- END WAYBACK TOOLBAR INSERT -->
<div align="center">  <!--- imagen arriba --->  <table width="600" border="0" cellspacing="0" cellpadding="0">    <tr>       <td><IMG height=66 src="img/top.jpg" width=600></td>    </tr>  </table><!--- fin imagen de arriba --->  <!--- menu primer nivel --->  <table width="600" border="0" cellspacing="0" cellpadding="0">      <tr>       <td><IMG border=0 height=28 src="img/menu-recursos.gif" useMap=#recursos width=600></td>    </tr>  </table>  <map name="recursos">  <area shape="RECT" coords="443,0,499,12" href="noticias.html">  <area shape="RECT" coords="510,0,598,12" href="contactenos.html">  <area shape="RECT" coords="532,17,598,25" href="recursos-fuentes.html">  <area shape="RECT" coords="426,18,525,27" href="recursos-artes.html">  <area shape="RECT" coords="347,18,420,27" href="recursos-articulos.html">  <area shape="RECT" coords="189,17,341,27" href="gratis.html">  <area shape="RECT" coords="370,0,435,12" href="recursos.html">  <area shape="RECT" coords="324,0,364,12" href="sinter.html">    <area shape="RECT" coords="226,0,283,13" href="tecapro.html">  <area shape="RECT" coords="179,1,222,13" href="index-2.html"></map><!--- fin menu primer nivel --->  <!--- menu tercer nivel --->  <table width="600" border="0" cellspacing="0" cellpadding="0">    <tr>       <td height="2"  bgcolor="#000000"><IMG alt="" border=0 height=5 src="img/blackline.jpg" width=600></td>    </tr>  </table><!--- fin menu tercer nivel ---><!--- B&uacute;squeda --->  <!--IWPBEGIN FORMDEBUSQUEDAS-->  <table width="600" border="0" cellspacing="5" cellpadding="0" valign="top">    <form name="datos" action="/web/20051030164234/http://196.40.15.121/scripts/genericCGI.exe" method="POST">	<tr valign="top">  	<td width=28%>           <input type="hidden" name="TIPO" value="CS">           <input type="hidden" name="REQUEST" value="BUSCAR">           <input type="hidden" name="WEBSITE" value="TKPRO">           <input type="hidden" name="NUMREQUEST" value="1">           <!--IWPBEGIN EXPRESION-->           <input type="Text" name="EXPRESION" size="20">           <!--IWPEND-->     </td>     <td width=9% valign="MIDDLE"><a href="JavaScript:document.datos.submit()"><img src="img/buscar.gif" border=0 width=50 height=17 alt=""></a></td>     <td width=9% valign="MIDDLE"><a href="como.html"><img src="img/como.gif" border=0 width=50 height=17 alt=""></a></td>     <td >      <a href="busqueda-a.html">        <font face="Arial,MS Serif" size="-2" color="blue">B&uacute;squeda avanzada</font>      </a>     </td>     <td align="RIGHT">     <img src="img/ENGLISH.jpg" width=75 height=15 border=0 alt="">     </td>  </tr>    </form>  </table><!--IWPEND--><!--- fin de B&uacute;squeda --->  <!--- main --->  <table width="600" border="0" cellspacing="5" cellpadding="0">  <tr>  <td> <!--IWPBEGIN BODY--><B><FONT FACE="Arial" SIZE=5><P ALIGN="CENTER">Specification of the Algorithm </P><P ALIGN="CENTER">THE "FROG" ENCRYPTION ALGORITHM</P></font></B><FONT FACE="Arial" SIZE=2><P ALIGN="CENTER">June 15, 1998</P><P ALIGN="CENTER">Authors: Dianelos Georgoudis, Damian Leroux, Billy Sim&oacute;n Chaves, TecApro International S.A.</P><B><P>Click here to download the FROG reference code: </P></B></FONT><P><A HREF="/web/20051030164234/http://tecapro.com/196.40.15.121/Encryption/frogc.zip"><FONT FACE="Arial" SIZE=2>C language source code</FONT></A><FONT FACE="Arial" SIZE=2> ( 24 kBytes) <BR></FONT><A HREF="/web/20051030164234/http://tecapro.com/196.40.15.121/Encryption/frogjava.zip"><FONT FACE="Arial" SIZE=2>Java source code</FONT></A><FONT FACE="Arial" SIZE=2> (41 kBytes) <BR></FONT><A HREF="/web/20051030164234/http://tecapro.com/196.40.15.121/Encryption/frogpasc.zip"><FONT FACE="Arial" SIZE=2>Pascal source code</FONT></A><FONT FACE="Arial" SIZE=2> (7 kBytes) </font></P><B><FONT FACE="Arial" SIZE=4><P>Table of Contents</P></font></B><P><A HREF="#b1"><FONT FACE="Arial" SIZE=2>B.1.</FONT></A><FONT FACE="Arial" SIZE=2> Introduction </font></P><P><A HREF="#b10"><FONT FACE="Arial" SIZE=2>B.1.0.</FONT></A><FONT FACE="Arial" SIZE=2> Conventions and Organization of this Document <BR></FONT><A HREF="#b11"><FONT FACE="Arial" SIZE=2>B.1.1.</FONT></A><FONT FACE="Arial" SIZE=2> Internal cycle <BR></FONT><A HREF="#b12"><FONT FACE="Arial" SIZE=2>B.1.2.</FONT></A><FONT FACE="Arial" SIZE=2> Key Setup <BR></FONT><A HREF="#b13"><FONT FACE="Arial" SIZE=2>B.1.3.</FONT></A><FONT FACE="Arial" SIZE=2> The Permutation Generation Algorithm <BR></FONT><A HREF="#b14"><FONT FACE="Arial" SIZE=2>B.1.4.</FONT></A><FONT FACE="Arial" SIZE=2> The Implementation of the <I>bombPermu</I> Restrictions </font></P><P><A HREF="#b2"><FONT FACE="Arial" SIZE=2>B.2.</FONT></A><FONT FACE="Arial" SIZE=2> Estimate of the Computational Efficiency </font></P><P><A HREF="#b21"><FONT FACE="Arial" SIZE=2>B.2.1.</FONT></A><FONT FACE="Arial" SIZE=2> On a Pentium platform <BR></FONT><A HREF="#b22"><FONT FACE="Arial" SIZE=2>B.2.2.</FONT></A><FONT FACE="Arial" SIZE=2> On a 8-bit computer </font></P><P><A HREF="#b3"><FONT FACE="Arial" SIZE=2>B.3.</FONT></A><FONT FACE="Arial" SIZE=2> Known Answer Tests and Monte Carlo Tests </font></P><P><A HREF="#b4"><FONT FACE="Arial" SIZE=2>B.4.</FONT></A><FONT FACE="Arial" SIZE=2> Expected Strength of the Algorithm </font></P><P><A HREF="#b5"><FONT FACE="Arial" SIZE=2>B.5.</FONT></A><FONT FACE="Arial" SIZE=2> Algorithm Analysis </font></P><P><A HREF="#b6"><FONT FACE="Arial" SIZE=2>B.6.</FONT></A><FONT FACE="Arial" SIZE=2> Advantages and Limitations </font></P><P><A HREF="#b61"><FONT FACE="Arial" SIZE=2>B.6.1.</FONT></A><FONT FACE="Arial" SIZE=2> Different Uses <BR></FONT><A HREF="#b62"><FONT FACE="Arial" SIZE=2>B.6.2.</FONT></A><FONT FACE="Arial" SIZE=2> Implementation of FROG in Various Environments <BR></FONT><A HREF="#b63"><FONT FACE="Arial" SIZE=2>B.6.3. </FONT></A><FONT FACE="Arial" SIZE=2>Other Key and Block Lengths <BR></FONT><A HREF="#b64"><FONT FACE="Arial" SIZE=2>B.6.4. </FONT></A><FONT FACE="Arial" SIZE=2>Other Advantages </font></P><P><A HREF="#b7"><FONT FACE="Arial" SIZE=2>B.7.</FONT></A><FONT FACE="Arial" SIZE=2> Possible Future Developments </font></P><B><FONT FACE="Arial" SIZE=4><P>B. Algorithm Specifications and Supporting Documentation</P></FONT><FONT FACE="Arial" SIZE=2><P><A NAME="b1"></A>B.1. Introduction</P></font></B><FONT FACE="Arial" SIZE=2><P>FROG is a new cipher with an unorthodox structure. Any symmetrical cipher's job is to conceal the plaintext's information through a computational process of confusion and diffusion. The basic idea behind the design of FROG is to conceal the definition of most of this process in a secret internal key. The actual encryption algorithm operates as an interpreter that regards the secret internal key as a program and executes it as if it were a series of primitive instructions. The goal is to deny the attacker as much knowledge as possible about the actual process being performed and therefore defeat any attack, whether publicly known or not. The encryption and decryption operations used in FROG are extremely simple. All the complexity lies within the internal key the details of which are unknown to an attacker.</P><P>FROG is very easy to implement (the reference C version has only about 150 lines of code). Much of the code needed to implement FROG is used to generate the secret internal key, the internal cipher itself is a very short piece of code. The implementation will run well on 8 bit processors because it uses only byte level instructions - the only arithmetic operation used is exclusive-OR and, optionally, 1 byte modulus. Also no bit specific operations are used. The algorithm is fairly fast, a version implemented using 8086 assembler achieves processing speeds of over 2.2 Mbytes per second when run on a 200 MHz Pentium PC. A version implemented using Pentium specific assembler would run even faster.</P><P>The FROG reference program included in this submission allows for user keys of any length between 5 bytes and 125 bytes (i.e. between 40 bits and 1000 bits in multiples of 8 bits). The block size is defined as a constant and is set equal to 16 bytes which is the minimum requirement for AES. Nevertheless, this constant can be given any value (even odd values) between 8 and 128 bytes in which case the re-compiled code will encrypt blocks whose sizes vary from a minimum of 64 bits up to a maximum of 1024 bits.</P><B><P><A NAME="b10"></A>B.1.0. Conventions and Organization of this Document </P></B><P>For simplicity, the description that follows is based on a block size of 16 bytes. No bit naming convention is specified because no bit operations are required. Byte values that appear in the examples are given as two digit Hex numbers starting with the most significant digit, e.g. A1 corresponds to the decimal value 161. FROG only uses byte arrays which are represented as V[ I ] where "V" is the name of the array and "I" is the index. An index of zero denotes the least significant byte of the array (i.e. the byte at the lowest position in memory). </P><P>Each part of the algorithm is formally specified using pseudo code. The pseudo code itself is not defined because its meaning should be clear to any programmer familiar with current day programming languages.</P><P>The diagrams used in the document are built from two elements: rectangular boxes that represent data and rounded boxes that represent processes. Figure 1, which shows the high level structure of FROG, illustrates the use of these elements.</P></FONT><FONT FACE="Arial"><P ALIGN="CENTER"><IMG SRC="Image14.gif" WIDTH=400 HEIGHT=317></P></FONT><P ALIGN="CENTER">&nbsp;</P><FONT FACE="Arial" SIZE=2><P>Section B.1.1. explains how the algorithm’s internal cycle, the FROG "interpreter" works. Sections B.1.2. - B.1.4. describe the internal key setup process of FROG. The organization of the rest of the document closely follows the structure specified in the NIST’s requirements for the documentation of candidate algorithms.</P><B><P><A NAME="b11"></A>B.1.1. Internal cycle</P></B><P>FROG uses 8 iterations. Each iteration uses one record of the internal key (called <I>internKey</I>), which is a data structure with eight records. Each of these records has three fields: an array of 16 bytes (called <I>xorBu</I>) which are used in an initial exclusive-OR operation with the block bytes, an array of 256 bytes (called <I>substPermu</I>) which represents a substitution table for byte values, and an array of 16 bytes (called <I>bombPermu</I>) each of which points to a different byte positions within the block (and therefore has a value between 0 and 15).</P><P>Each iteration traverses sequentially the 16 byte block (from the least significant byte up to the most significant byte) and performs four basic operations on each byte. The first two operations implement confusion and the last two implement diffusion:</P><P><B>step 1</b>: Exclusive-OR the next byte of the block with the next byte of the <I>xorBu</I> field.</P><P><B>step 2</b>: Replace the byte computed in step 1 by the byte in the substitution table (<I>substPermu</I>) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indexed by it.</P><P><B>step 3</b>: Modify the next byte in the block by exclusive-ORing it with the byte computed in step 2. &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;When the end of the block is reached then the least significant byte of the block is<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;considered to be the "next" byte.</P><P><B>step 4</b>: Use the next byte of the <I>bombPermu</I> array to define a position in the block. Modify the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;byte in this position of the block by Exclusive-ORing it with the byte computed in step 2.</P></FONT><FONT FACE="Arial"><P ALIGN="CENTER"><IMG SRC="Image15.gif" WIDTH=400 HEIGHT=317></P></FONT><FONT FACE="Arial" SIZE=2><P>The encryption process can be represented by the following pseudo code, in which "&lt;=" denotes the assignment operation, and <I>blockSize</I> is the size in bytes of the block to be encrypted.</P><P><B><U>Procedure</u> </b><I>FROG-encrypt </I>( <I>plainText</I>, <I>cipherText</I>, <I>internKey</I>)</P><P>// convert plaintext into ciphertext<BR><B>copy</B> <I>plainText</I> <B>into</B> <I>cipherText<BR></I><B>for each of the eight records in </B><I>internKey</I><B> do</b></P><B><U><P>begin</P></u></B><P>//<I>xorBuf, substPermu, bombPermu</I> denote the fields of the current record<BR><B>for each byte in </B><I>cipherText </I><B>do</B><I> </I>[I &lt;= 0 <B>to</B> <I>blockSize</I>-1]</P><B><U><P>begin</P></u></B><P><I>cipherText</i>[I] &lt;= <I>cipherText</I>[I] <B>XOR</B> <I>xorBu</I>[I]<BR><I>cipherText</I>[I] &lt;= <I>substPermu</I>[ <I>cipherText</I>[I] ]<BR><B>if </B>I&lt;<I>blockSize</I>-1 <BR><B>then</B> <I>cipherText</I>[I+1] &lt;= <I>cipherText</I>[I+1] <B>XOR</B> <I>cipherText</I>[I]<BR><B>else</B> <I>cipherText</I>[0] &lt;= <I>cipherText</I>[0] <B>XOR</B> <I>cipherText</I>[I]<BR>K &lt;<I>= bombPermu</I>[I]<BR><I>cipherText</I>[K] &lt;= <I>cipherText</I>[K] <B>XOR</B> <I>cipherText</I>[I]</P><B><U><P>end</P><P>end</P><P>End Procedure</P></u></B><P>The following example will clarify this very simple process. All values are in HEX starting with the least significant byte. First we define an internal key record with the following values (starting with the less significant byte indexed by zero):</P></FONT><I></I><P><FONT FACE="Courier" SIZE=2><I>xorBu</i></font><FONT FACE="Courier" SIZE=2>: 05 f0 a3 ...<BR><I>substPermu</I>: a2 16 08 bb 03 f1 ...<BR><I>bombPermu</I>: 03 0f 00 ...</font></P><FONT FACE="Arial" SIZE=2><P>Let us now start encrypting the following plaintext block:</P></FONT><FONT FACE="Courier" SIZE=2><P>00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0f</P></FONT><FONT FACE="Arial" SIZE=2><P>and show the intermediate states of the block after each step:</P><P>Processing byte in position 0:</P></FONT><FONT FACE="Courier" SIZE=2><P>1. step: 05 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0f<BR>2. step: f1 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0f<BR>3. step: f1 f0 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0f<BR>4. step: f1 f0 02 f2 04 05 06 07 08 09 0a 0b 0c 0d 0f</P></FONT><FONT FACE="Arial" SIZE=2><P>Processing byte in position 1:</P></FONT><FONT FACE="Courier" SIZE=2><P>1. step: f1 00 02 f2 04 05 06 07 08 09 0a 0b 0c 0d 0f<BR>2. step: f1 a2 02 f2 04 05 06 07 08 09 0a 0b 0c 0d 0f<BR>3. step: f1 a2 a0 f2 04 05 06 07 08 09 0a 0b 0c 0d 0f<BR>4. step: f1 a2 a0 f2 04 05 06 07 08 09 0a 0b 0c 0d ad</P></FONT><FONT FACE="Arial" SIZE=2><P>Processing byte in position 2:</P></FONT><FONT FACE="Courier" SIZE=2><P>1. step: f1 a2 03 f2 04 05 06 07 08 09 0a 0b 0c 0d ad<BR>2. step: f1 a2 bb f2 04 05 06 07 08 09 0a 0b 0c 0d ad<BR>3. step: f1 a2 bb 49 04 05 06 07 08 09 0a 0b 0c 0d ad<BR>4. step: 4a a2 bb 49 04 05 06 07 08 09 0a 0b 0c 0d ad</P></FONT><FONT FACE="Arial" SIZE=2><P>And so on. The confusion and diffusion process is fast and after only 3 iterations any statistical redundancies in the plaintext are obscured. Eight iterations were chosen as the basis for the FROG algorithm so as to ensure that the ciphertext generated has very good random properties.</P><P>Observe that the first two steps in the process are equivalent to using 16 different substitution tables for each of the 16 bytes in the block, which increases the confusion achieved by these steps. The last two steps diffuse the result of this substitution process throughout the block. Two such operations were chosen so as to achieve an exponential speed of diffusion.</P><P>Notice that all the steps in the process are simple invertible operations. The decryption process traverses the internal key and the ciphertext block in the opposite direction, "undoing" all primitive operations performed during the encryption process, and thus recovering the plaintext. The internal key used in the decryption process is identical, except that all substitution tables (fields <I>substPermu</I>) are replaced by their inverse:</P><P><B><U>Procedure</u> </b><I>FROG-decrypt </I>( <I>cipherText</I>, <I>plainText</I>, <I>internKey</I>)</P><P>// convert ciphertext into plaintext <BR><B>copy</B> <I>cipherText</I> <B>into</B> <I>plainText<BR></I><B>for each of the eight records in </B><I>internKey</I><B> traversed in opposite direction do</b></P></FONT><P>&nbsp;</P><B><U><FONT FACE="Arial" SIZE=2><P>begin</P></font></u></B><FONT FACE="Arial" SIZE=2><P>//<I>xorBuf, substPermu, bombPermu</I> denote the fields of the current record<BR><B>for each byte in </B><I>plainText </I><B>do</B><I> </I>[I &lt;= <I>blockSize</I>-1 <B>down to </B>0]</P><B><U><P>begin</P></u></B><P>K &lt;<I>= bombPermu</I>[I]<BR><I>plainText</I>[K] &lt;= <I>plainText</I>[K] <B>XOR</B> <I>plainText</I>[I] <BR><B>if </B>I&lt;<I>blockSize</I>-1 <BR><B>then</B> <I>plainText</I>[I+1] &lt;= <I>plainText</I>[I+1] <B>XOR</B> <I>plainText</I>[I]<BR><B>else</B> <I>plainText</I>[0] &lt;= <I>plainText</I>[0] <B>XOR</B> <I>plainText</I>[I]<BR><I>plainText</I>[I] &lt;= <I>substPermu</I>[ <I>plainText</I>[I] ]<BR><I>plainText</I>[I] &lt;= <I>plainText</I>[I] <B>XOR</B> <I>xorBu</I>[I]</P><B><U><P>end</P><P>end</P><P>End Procedure</P></u></B><P>The <I>bompPermu</I> field is used to rapidly diffuse any change in the input throughout the block. In order to speed up as much as possible this diffusion process the <I>bombPermu</I> field should satisfy three conditions:</P></FONT> <OL TYPE="a"><OL TYPE="a"><FONT FACE="Arial" SIZE=2><LI>It must be a permutation, i.e. each of the block positions should be pointed at least once. In this way all positions in the block are exclusive OR-ed (bombed) with values that come from the substitution table indexed by another byte. </LI><LI>Second, the permutation should have a cycle length equal to the size of the block (16 in this case), that is to say if one regards the permutation of N numbers as a pointer chain, all N positions should be traversed before cycling back into the initial position. This is normally not the case with random permutations. For example, if we take a permutation of length 5, "4,0,3,2,1" and start at the first element (a 4 in position 0) we cycle back after only 3 transitions: 4 -&gt; 1 -&gt; 0 -&gt;4. An example of a permutation with cycle length 5 is: "3,4,0,1,2". The rationale here is that if one uses a permutation with a cycle length smaller than the length of the block then the "bombing" effect is limited within sub-groups of elements in the block. </LI><LI>An element in the permutation must never point to the next element, i.e. the i-th element of the array must never contain the value i+1. In this way one guarantees the fourth step in the process (as described above) will not invert the diffusing effect of the third step. </LI></font></OL></OL><FONT FACE="Arial" SIZE=2><P>It is interesting to note that the most important condition is the third one. A version of FROG that completely omits the implementation of the first and second conditions works almost as well as the standard version, and is simpler to implement.</P><P>Section B.1.3. describes the algorithm that generates permutations required by the first condition , and section B.1.4. describes the algorithms used to implement the second and third conditions. Section B.7 about possible future developments of FROG also refers to these conditions.</P><P>Observe that the block size is not a limiting factor for the operation of the FROG algorithm. For example, if we want to use a block size of 17 bytes, then the algorithm would still work as long as we reserve 17 arbitrary bytes for the <I>xorBu </I>array, and 17 bytes with values between 0 and 16 for the <I>bombPermu</I> array.</P><B><P><A NAME="b12"></A>B.1.2 Key Setup</P></B><P>FROG computes the internal key as a function of the user key. As explained above each of the eight iterations uses a record that has 16 bytes for the <I>xorBuf </I>field, 256 bytes for the <I>substPermu </I>field and 16 bytes for the <I>bombPermu</I> field, so therefore the internal key contains 2,304 bytes. The Key Setup process of FROG is recursive: first it builds a simple internal key, then it uses FROG encryption in CBC (Cipher Block Chaining) mode to produce the definitive internal key. Figure 3 illustrates this process:</P></FONT><FONT FACE="Arial"><P ALIGN="CENTER"><IMG SRC="Image16.gif" WIDTH=500 HEIGHT=519></P></FONT><FONT FACE="Arial" SIZE=2><P>As you can see in Fig 3, the large internal key is produced recursively, using the following two algorithms:</P><P>The first algorithm (function <I>makeInternalKey</I>) takes an unstructured, arbitrary array of 2,304 bytes and transforms it into a valid internal key. Specifically, it computes the permutation arrays <I>substPermu</I> and <I>bombPermu</I> for each of the eight records. To do this an algorithm is used (function <I>makePermutation</I> described in section B.1.3) that takes an array of N arbitrary bytes and returns a permutation with values 0 to N-1. If the internal key is to be used for decryption, then<I> substPermu</I> is inverted. The field <I>bombPermu</I> is further validated (see section B.1.4) in order to fulfill the special conditions described in the previous section. Fig 4 illustrates this process:</P></FONT><FONT FACE="Arial"><P ALIGN="CENTER"><IMG SRC="Image17.gif" WIDTH=400 HEIGHT=345></P></FONT><FONT FACE="Arial" SIZE=2><P>The <I>makeInternalKey</I> algorithm in the key creation process can be represented by the following pseudo code:</P><B></B><P><U><B>Procedure</b></u> <I>makeInternalKey</I><B> (</B><I>internKey</I><B>)</b></P><P><B>// </b>convert <I>internKey</I> into a valid FROG internal key<BR><B>for each of the eight records in</B> <I>internKey </I><B>do</b></P><B><U><P>begin</P></u></B><P>// <I>xorBuf, substPermu, bombPermu</I> denote the current records’ fields<BR><I>makePermutation of 256 bytes</I> (<I>substPermu</I>)<BR><B>if </B>internal key is for decryption <B>then</B> <I>invert(substPermu)<BR>makePermutation of blockSize bytes</I> (<I>bombPermu</I>)<B> <BR></B><I>Validate(</I> <I>bombPermu)</i></P><B><U><P>end</P><P>End Procedure</P></u></B><P>The functions <I>makePermutation </I>and <I>Validate </I>are defined in sections B.1.3 and B.1.4 respectively.</P><P>The second algorithm (function <I>hashKey</I>) takes a key (with size between 5 and 125 bytes) and produces a 2,304 bytes long array (called <I>randomKey</I>) without loosing any entropy and filling it with data which statistically appears to be random. This is done in three steps as follows:</P><P><B>Step 1.</b> A 2,304 bytes long array (called <I>simpleKey</I>) is filled with data that depends on both the user key and <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; an internal constant (called <I>randomSeed</I>) which is filled with 251 true random bytes. s<I>impleKey</I> is first<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; filled sequentially with copies of the user key, and then copies of the <I>randomSeed</I> are sequentially<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exclusive-ORed on top of this. Any trailing bytes are ignored. The resulting array is then processed by<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the function <I>makeInternalKey</I> and transformed into a valid internal key for FROG.</P><P><B>Step 2.</b> An IV (Initialization Vector) is created using the less significant 16 bytes of the user key (if the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; key has less then 16 bytes, then the rest is filled with zeros). Then a value corresponding to the<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; length of the user key in bytes (e.g. 16, 24 or 32 correspond to the 128-, 192- and 256-bit key sizes) is<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exclusive-ORed with the least significant byte of the IV (this is to ensure that different sizes of user<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; key always produce different ciphertexts).</P><P><B>Step 3.</b> FROG encryption function is then called to encrypt a zero filled array of 2,304 bytes in CBC<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (Cipher Block Chaining) mode using the internal key computed in step (a) and the IV computed in <BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; step (b). The result of this encryption process is an array (called <I>randomKey</I>) with very<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; good statistical randomness. </P><P>Finally, this array is processed by the function <I>makeInternalKey</I> and transformed into the valid internal key. This completes the creation of the internal key which is then used to drive the encryption or decryption process.</P><P>The <I>hashKey</I> algorithm can be represented by the following pseudo code:</P><B></B><P><U><B>Procedure </b></u><I>hashKey </I>( <I>userKey, keyLen, randomKey </I>)</P><P>// hash <I>userKey</I> into a <I>randomKey</I> array of <I>internalKeySize </I>bytes (normally 2,304)<BR>//<I> keyLen </I>is the user key’s length in bytes</P><P>// Step a: create <I>simpleKey</i></P><P><B>declare</b> <I>simpleKey</I> array of <I>internalKeySize </I>bytes<BR>S &lt;= 0<BR>K &lt;= 0<BR><B>for each byte in </B><I>simpleKey</I> <B>do</B> [I &lt;= 0 to <I>internalKeySize</I>-1]</P><B></B><P><U><B>begin<BR></b></u><I>simpleKey</I>[I] &lt;= <I>randomSeed</I>[S] XOR user<I>Key</I>[K]<BR><B>if </B>S &lt; 250 <B>then</B> S &lt;= S+1 <B>else </B>S &lt;= 0<BR><B>if</B> K &lt; <I>keyLen</I>-1 <B>then</B> K &lt;= K+1 <B>else </B>K &lt;= 0<BR><B><U>end</u></b></P><P>// convert <I>simpleKey </I>into valid FROG internal key<BR><I>makeInternalKey for encryption (simpleKey</I>) </P><P>// Step b: create <I>buffer</I> to be used subsequently as IV </P><P><B>declare</b> <I>buffer</I> array of <I>blockSize </I>bytes and initialize with zeros<BR><I>last </I>&lt;= <I>keyLen</I>-1<BR><B>if</B> <I>last</I> greater or equal <I>blockSize</I> <B>then</B> <I>last </I>&lt;= <I>blockSize</I>-1<BR><B>for</B> I &lt;= 0 <B>to</B> <I>last</I> <B>do</B> <I>buffer</I>[I] &lt;= <I>buffer</I>[I] XOR <I>userKey</I>[I]<BR><I>buffer</I>[0] &lt;= <I>buffer</I>[0] XOR <I>keyLen</i></P><P>// Step c: call FROG encryption in CBC mode and produce <I>randomKey</I> </P><P>I &lt;= 0<BR><B>repeat </b></P><B></B><P><U><B>begin</b></u> <BR><I>FROGencrypt</I> (<I>buffer, simpleKey, buffer</I>)<BR><I>size </I>&lt;= internalKeySize - I<BR><B>if</B> <I>size </I>&gt; <I>blockSize</I> <B>then</B> <I>size </I>&lt;= <I>blockSize<BR></I><B>copy</B> <I>size </I>bytes of <I>buffer</I> into <I>randomKey</I>[I]<BR>I &lt;= I+<I>size<BR></I><B><U>end</u></b></P><P><B>until </b>I equal<B> </B><I>internalKeySize </i></P><B><U><P>End Procedure </P></u></B><P>The 251 bytes of <I>randomSeed</I> is the only constant table used in FROG. Its definition is based on the initial sequence of numbers included in "A Million Random Digits" published by the RAND corporation in 1955. These are listed in groups of five decimal digits. <I>randomSeed </I>is initialized with the modulo 256 value of the numbers represented by the first 251 groups in this table. For example, the first group is 10097, which modulo 256 equals 113, the second group is 32533 which modulo 256 equals 21, etc. Here are the values (in decimal notation) of the <I>randomSeed</I> table, starting with the least significant byte:</P><P>113, 21,232, 18,113, 92, 63,157,124,193,166,197,126, 56,229,229, <BR>156,162, 54, 17,230, 89,189, 87,169,&nbsp; 0, 81,204,&nbsp; 8, 70,203,225, <BR>160, 59,167,189,100,157, 84, 11,&nbsp; 7,130, 29, 51, 32, 45,135,237, <BR>139, 33, 17,221, 24, 50, 89, 74, 21,205,191,242, 84, 53,&nbsp; 3,230, <BR>231,118, 15, 15,107,&nbsp; 4, 21, 34,&nbsp; 3,156, 57, 66, 93,255,191,&nbsp; 3, <BR>85,135,205,200,185,204, 52, 37, 35, 24, 68,185,201, 10,224,234, <BR>&nbsp; 7,120,201,115,216,103, 57,255, 93,110, 42,249, 68, 14, 29, 55, <BR>128, 84, 37,152,221,137, 39, 11,252, 50,144, 35,178,190, 43,162, <BR>103,249,109,&nbsp; 8,235, 33,158,111,252,205,169, 54, 10, 20,221,201, <BR>178,224, 89,184,182, 65,201, 10, 60,&nbsp; 6,191,174, 79, 98, 26,160, <BR>252, 51, 63, 79,&nbsp; 6,102,123,173, 49,&nbsp; 3,110,233, 90,158,228,210, <BR>209,237, 30, 95, 28,179,204,220, 72,163, 77,166,192, 98,165, 25, <BR>145,162, 91,212, 41,230,110,&nbsp; 6,107,187,127, 38, 82, 98, 30, 67, <BR>225, 80,208,134, 60,250,153, 87,148, 60, 66,165, 72, 29,165, 82, <BR>211,207,&nbsp; 0,177,206, 13,&nbsp; 6, 14, 92,248, 60,201,132, 95, 35,215, <BR>118,177,121,180, 27, 83,131, 26, 39, 46, 12 </P><B><P><A NAME="b13"></A>B.1.3 The Permutation Generation Algorithm</P></B><P><I>makePermutation</i> is a general purpose algorithm that takes an input array of bytes and returns a permutation of the same length. In this context permutation means an array of length N that holds all values between 0 and N-1 without any repetition.</P><P>The algorithm works as follows:</P><P>An array called "<I>use</I>" is initialized sequentially with all values between 0 and N-1. The permutation is created sequentially one byte at a time taking bytes from the "<I>use</I>" array. When a byte is used it is removed from the "<I>use</I>" array and the length of the array is decreased by 1. In this way it is guaranteed that the same value will never used twice in the permutation. The values of the input array are used to compute an index into the "<I>use</I>" array. When computing the i-th element of the permutation this index is computed by adding the previous index used with the i-th byte of the input array:</P></FONT><FONT FACE="Courier" SIZE=2><P>index_i = ( index_(i-1) + input[i] ) mod (length of "use" array)</P></FONT><FONT FACE="Arial" SIZE=2><P>The modulo operation is necessary to guarantee that the index computed will point to a valid position. For the first iteration, the "previous index" is initialized to zero. </P><P>The following example shows the conversion of the 8 element input array (105,135,188,156,103,91,68,208) into a permutation (numbers are given in decimal notation). </P><P>In the first iteration </P></FONT><FONT FACE="Courier" SIZE=2><P>index = (0 + 105) mod 8 = 1. In the use array "1" indexes a 1 which becomes the first element of the permutation. Remove 1 from the "use" array.</P></FONT><FONT FACE="Arial" SIZE=2><P>In the second iteration </P><P>index = (1 + 135) mod 7 = 3. In the use array "3" indexes a 4 which becomes the second element of the permutation. Remove 4 from the "use" array.</P><P>And so on. Fig 5 illustrates the full process. Observe how the permutation array is created step by step The final permutation is (1,4,7,2,0,5,6,3):</P></FONT><FONT FACE="Arial"><P ALIGN="CENTER"><IMG SRC="Image20.gif" WIDTH=500 HEIGHT=434></P></FONT><FONT FACE="Arial" SIZE=2><P>The function for creating permutations can be represented by the following pseudo code:</P><B></B><P><U><B>Procedure </b></u><I>makePermutation </I>(<I>input</I>, <I>lastElem) </i></P><P>// inputs an array of <I>latsElem+</I>1 bytes and converts it into a permutation <BR><B>declare </B>array <I>use</I> of <I>lastElem</I>+1 bytes<I> <BR></I><B>for </B>I &lt;= 0 <B>to</B> <I>lastElem</I> <B>do</B> use[I] &lt;= I <BR><I>last </I>&lt;= <I>lastElem</I> <BR><I>index </I>&lt;= 0 <BR><B>for</B> <B>all bytes of </B><I>input </I>[ I &lt;= 0 <B>to</B> lastElem-1 ] <B>do </b></P><B></B><P><U><B>begin <BR></b></u><I>index </I>&lt;= (<I>index</I>+<I>input</I>[I]) mod (<I>last</I>+1) <BR><I>input</I>[I] &lt;= <I>use</I>[<I>index</I>] <BR><B>if</B> <I>index</I> &lt; <I>last</I> <B>then</B> remove element pointed by <I>index</I> from the <I>use </I>array <BR><I>last</I> &lt;= <I>last</I> - 1 <BR><B>if</B> <I>index</I> &gt; <I>last</I> <B>then</B> <I>index </I>&lt;= 0 <BR><B><U>end </u></b></P><P><I>input</i>[<I>lastElem</I>] &lt;= <I>use</I>[0] </P><B><U><P>End Procedure </P></U><P><A NAME="b14"></A>B.1.4 The Implementation of the <I>bombPermu</I> Restrictions</P></B><P>The first restriction on the permutation <I>bombPermu</I> is that it must have a cycle length equal to the block size (16 in this case). If the permutation is regarded as a pointer list then it can interpreted as a single closed linked list or as a group of closed linked lists. The task at hand is to create a permutation that correspond to single closed linked list. To achieve this the algorithm proceeds as follows: starting at the first element it traverses the list. If it arrives back to the first element before having used up all values of the permutation then it looks for the fist position in the permutation that it has not yet traversed. This position holds a value that can serve as the start of another linked list. The algorithm then merges these two lists into one. This process is repeated until all the elements have been traversed, that is to say until only one list remains.</P><P>For example, the permutation 3,0,5,1,2,4 can be interpreted as to two closed linked lists, as follows: the element in position 0 is 3 which indexes the position in the permutation which holds a 1, which indexes the position in the permutation that holds a 0, which indexes the starting position. In this way we get the first closed linked list: 3-&gt;1-&gt;0-&gt;3. The last position traversed is position 1 which holds the value 0. The fist position not yet traversed is the position 2 that holds a 5. This value forms the start of the second linked list which is 5-&gt;4-&gt;2-&gt;5. These two lists are now merged together in a two step process. First change the value in position 1 from to 0 to 2. Now we have an incomplete list: 3-&gt;1-&gt;2-&gt;5-&gt;4-&gt;2-&gt;5. To close this list the value in position 4 is changed from 2 to 0: 3-&gt;1-&gt;2-&gt;5-&gt;4-&gt;2-&gt;0-&gt;3. The resulting permutation 3,2,5,1,0,4 has a cycle length of 6 so we have finished. Fig 6 clarifies this operation:</P></FONT><FONT FACE="Arial"><P ALIGN="CENTER"><IMG SRC="Image22.gif" WIDTH=400 HEIGHT=341></P></FONT><FONT FACE="Arial" SIZE=2><P>The second restriction on the permutation <I>bombPermu</I> is that no element should point to the next position in the list. This requirement is fulfilled by traversing the permutation array from the least significant byte to the most significant byte and testing whether P(i)=(i+1) mod (block size). If this is so P(i) is simply redefined to point one position further to the right P(i)= (i+2) mod (block size). </P><P>This last process is very fast but, unfortunately, it will normally destroy the carefully crafted permutation. Even so FROG retains its excellent diffusion speed which is the goal of both these processes.</P><P>The function for applying the <I>bombPermu</I> conditions can be represented by the following pseudo code:</P><B></B><P><U><B>Procedure</b></u> <I>Validate</I><B> </B>(<I>bombPermu</I>) </P><P>// make certain that <I>bombPermu</I> has a cycle length of <I>blockSize <BR></I><B>declare </B><I>used </I>array of <I>blockSize</I> bytes <BR><B>fill </B>array <I>used</I> <B>with</B> false <BR><I>index</I>&lt;=0 <BR><B>for all but last element in</B> <I>bombPerm</I> [ I &lt;= 0 <B>to</B> <I>blockSize</I>-2 ] <B>do </b></P><P><B><U>begin</u> <BR>if </b><I>bombPermu</I>[<I>index</I>]=0 <B>then //</B> short cycle found </P><B></B><P><U><B>begin <BR></b></u>K &lt;= <I>index <BR></I><B>repeat</B> K&lt;=(K+1) mod <I>blockSize</I> <B>until</B> NOT <I>used</I>[k] //first position not yet traversed <BR><I>bombPermu</I>[<I>index</I>] &lt;= K <BR>L &lt;= K <BR><B>while </B><I>bombPermu</I>[L] not equal K <B>do</B> L &lt;= BombPermu[L] //find who points to K <BR><I>bombPermu</I>[L] &lt;= 0 // now cycles are merged <BR><B><U>end </u></b></P><P><I>used</i>[<I>index</I>] &lt;= true <BR><I>index </I>&lt;= <I>BombPermu</I>[<I>index</I>] // continue searching <BR><B><U>end</u></b></P><P>// now make certain that no element of <I>bombpermu</I> points to next element <BR><B>for all elements</B> <B>in</B> <I>bombPermu</I> [I&lt;=0 to <I>blockSize</I>-1] <B>do <BR>if</B> <I>bombPermu</I>[I] equal (I+1) mod <I>blockSize</I> <B>then</B><I> bombPermu</I>[I] &lt;= (I+2) mod <I>blockSize </i></P><B><U><P>End Procedure </P></U><P><A NAME="b2"></A>B.2 Estimate of the Computational Efficiency </P></B><P>The following data is based on the optimized ANSI C version of FROG as submitted in the present package. When running on the NIST AES analysis platform (a 200 MHz Pentium PC) it encrypts 1.3 Mbytes per second and decrypts 1.7 Mbytes per second. The key setup takes a relatively long 10 msec. An implementation that includes 16 bit 8086 assembler code for the inner cycle encrypts over 2.2 Mbytes per second on the same platform. An implementation that uses Pentium specific instruction set should encrypt and decrypt over 3.0 Mbytes per second (approximately 50 cycles per byte). </P><P>FROG’s inner cycle processes each 16 byte block in a sequential manner. Even so a hardware implementation of FROG should be able to implement one iteration in approximately 20 clock cycles. A pipelined IC would then be able to process 0.8 bytes per cycle, e.g. a 200 MHz chip would process 160 Mbytes per second (1.3 Gbps).</P><P>The size of the user key (128, 196, or 256 bits) does not affect the speed of the algorithm because the user key is used only to initialize the internal key during the setup process. Also observe that the same computational effort must invested in key setup and in key change. There are no tradeoffs between speed and memory in the implementation of FROG. </P><B><P><A NAME="b21"></A>B.2.1. On a Pentium platform</P></B></FONT><FONT FACE="Courier" SIZE=2><P>Program: ANCI C optimized version included in this submission.<BR>Platform: 200 MHz Pentium PC, 64 MB of RAM, Windows 95 </P><P>Speed estimate in clock cycles</P></FONT><FONT FACE="Courier"><PRE> Key/Block size               128/128    192/128    256/128  Encrypt one data block         2,600      2,600      2,600  Decrypt one data block         1,980      1,980      1,980  Key setup                  1,960,000  1,960,000  1,960,000  Algorithm setup                  125        125        125  Key change                 1,960,000  1,960,000  1,960,000  </PRE></FONT><FONT FACE="Arial" SIZE=2><P>In FROG encryption and decryption represent identical workload. The fact that a Pentium decrypts faster than it encrypts is related to internal CPU optimizations. </P><B><P><A NAME="b22"></A>B.2.2. On a 8-bit computer</P></B></FONT><FONT FACE="Courier" SIZE=2><P>Program: Z80 assembly for internal cycle. <BR>Platform: 2.5 MHz Z80, 64 kB of memory running under CP/M. </P><P>Speed estimate in clock cycles</P></FONT><PRE></PRE><FONT FACE="Courier" SIZE=2><P>Key/Block size 128/128 192/128 256/128 </P><P>Encrypt one data block 17,900 17,900 17,900 Decrypt one data block 17,900 17,900 17,900 Key setup 15,000,000 15,000,000 15,000,000 Algorithm setup 200 200 200 Key change 15,000,000 15,000,000 15,000,000 </P></FONT><B><FONT FACE="Arial" SIZE=2><P><A NAME="b3"></A>B.3. Known Answer Tests and Monte Carlo Tests</P></font></B><FONT FACE="Arial" SIZE=2><P>These are submitted as text files on a separate diskette. The hexadecimal numbers that appear in the tests use the convention that the leftmost character represents the most significant hexadecimal digit, i.e. the 4 most significant bits. For example the decimal number 1000 is represented by 3e8. </P><P>The NIST specifications for the test were interpreted by taking bit 1 as the most significant bit and bit 128 as the least significant bit of a 128 bit block. </P><B><P><A NAME="b4"></A>B.4. Expected Strength of the Algorithm</P></B><P>No attacks more efficient than exhaustive key search are known. The expected workfactor of the algorithm is therefore O(2^(N-1)) where N is number of bits in the user key, i.e. O(2^127) for a 128 bit key, O(2^191) for a 192 bit key and O(2^255) for a 256 bit key.</P><B><P><A NAME="b5"></A>B.5. Algorithm Analysis</P></B><P>The design of FROG was guided by the goal to implement a cipher which is as simple as possible algorithmically but as complex as possible to model mathematically. The first characteristic produces efficiency and design transparency; the second produces strength, because in the absence of a mathematical model, the attacker can only search for statistical weaknesses in the algorithm which in the case of FROG are believed to be absent.</P><P>Most internal transformations, including the substitution tables and the tables that guide the diffusion process depend on the internal key and are therefore unknown. The internal key is itself built by calling the FROG algorithm recursively and depends therefore on the user key in a very complex manner. No known or chosen plaintext attacks are expected to work.</P><P>No weak keys or equivalent keys or keys with complementation properties are known and none are expected to exist. There are no restrictions at all on key selection.</P><P>The simplicity of the structure of FROG and the absence of any constant tables preclude the possibility of a trap-door. The code in FROG has clear goals: the inner cycle implements two primitive operations for confusion and two more for diffusion. The internal key is constructed recursively and the structure chosen for the internal key obeys either design requirements or were chosen to accelerate the diffusion process. The only rather arbitrary code in FROG is the creation of the simple internal key (<I>simpleKey</I>) during the key setup process, in which as many copies as needed of the user key are just linked together. This happens to be the simplest way to create this key. However, a more significant argument is that the way <I>simpleKey</I> is initialized is not important to the strength of the cipher; in fact it can be changed deliberately so as to produce non-standard versions of FROG (the advantage of doing this is explained in B.6.)</P><P>One constant table (<I>randomSeed</I>) is included in FROG but its definition is based on random data that have been publicly known for the last 40 years (the RAND tables) and therefore no trapdoor can be hidden in this table. Moreover, the values in this table do not seriously affect the strength of the algorithm, you can fill this table with any random values and the resulting variant of FROG will work well. The purpose of this table is to increase the flexibility of the algorithm because it can be used to implement a master key (also see B.6). </P><P>There are no published materials relating to FROG.</P><B><P><A NAME="b6"></A>B.6. Advantages and Limitations</P></B><P>FROG displays several positive characteristics:</P></FONT> <UL><FONT FACE="Arial" SIZE=2><LI>Simplicity of design</LI></FONT> <FONT FACE="Arial" SIZE=2><LI>Speed of operation</LI></FONT> <FONT FACE="Arial" SIZE=2><LI>Flexibility of key and block sizes</LI></FONT> <FONT FACE="Arial" SIZE=2><LI>Variability (it can easily be customized)</LI></FONT> </UL><FONT FACE="Arial" SIZE=2><P>These advantages are described below.</P><P>Its only limitation that may be significant for some applications is its relatively long setup time (see section B. 7 for ideas on how the setup time might be reduced).</P><B><P><A NAME="b61"></A>B.6.1. Different Uses</P></B><P>FROG can be used to implement a stream cipher with no loss of security.</P><P>FROG can be used to implement a MAC (Message Authentication Code), for example by encrypting a message in CFB (Cipher Feedback Mode). FROG's flexibility to allow for any plaintext sizes between 64 and 1024 bits can be helpful in this case, for example if you need an 80 bit MAC for an 800 bit long message. There are no known weaknesses when FROG is used to implement a hash algorithm or a MAC but, no tests have so far been conducted to check this experimentally.</P><P>During the design of FROG, powerful statistical analysis tools were used to determine whether FROG produces good pseudo-random output even when implemented with low iteration counts. FROG can certainly be used as a pseudo-random number generator, for example by initializing a plaintext with the generator's seed, exclusive OR-ing this plaintext with a sequential counter, and encrypting the resulting block to produce the next block of pseudorandom bits.</P><P>No other limitations of FROG relating to different potential uses of the cipher are known. </P><B><P><A NAME="b62"></A>B.6.2. Implementation of FROG in Various Environments</P></B><P>FROG is very well suited for implementation on 8 bit processors (such as the ones included in smart cards or other embedded applications). It uses only byte instructions and can be implemented by a short program. </P><P>FROG is not very well suited for a pure IC (Integrated Circuit) hardware implementation, as its design flows from software engineering concepts. It certainly can be implemented in an ASIC (Application Specific Integrated Circuit), however a gate count cannot be estimated at this time and might be high.</P><P>A better solution, would be to implement a simple ASIC for the encryption and decryption processes only and to implement the key setup by software for an embedded processor. The algorithm's inner cycle operations on each byte of the block are so simple that they can be implemented in about 7 assembly language instructions using the 8086 assembly set. If FROG becomes the AES, future microprocessors designers might want to consider implementing these as a single machine instruction. This would allow pure software implementations of FROG to reach speeds of about 10 CPU cycles per byte.</P><P>ATM, HDTV and B-ISDN are fast communication technologies and in this context FROG's speed is an advantage. However, FROG is relatively slow during the key setup process which could limit its usefulness in some situations. The time needed for the key setup process is proportional to the encryption speed, because typically over one hundred encryptions must be executed to create the internal key. If the encryption speed is further optimized (for example, by implementing the internal cycle in hardware), then the key setup speed will increase very significantly. In some cases, such as smart-card applications or pre-paid cellular phones, the large internal key could be pre-computed and pre-loaded. FROG needs very little memory to operate efficiently, typically less than 2,500 bytes if a pre-loaded internal key is used and less than 5,000 bytes when key setup is included in the algorithm. </P><P>No other advantages or limitations concerning the implementation of FROG for use with ATM, HDTV or B-ISDN are known at present.</P><B><P><A NAME="b63"></A>B.6.3. Other Key and Block Lengths</P></B><P>In this context FROG is extremely flexible. The reference code included here allows for key lengths between 40 and 1000 bits in 8 bit (1 byte) increments. Even though the code submitted sets the size block to a constant 16 bytes (or 128 bits which is the minimum requirement), this constant (<I>CODE_SIZE</I>) can be modified and set to any value between 8 and 128 (bytes) and the code can be recompiled to produce instances of FROG that encrypt blocks from 64 bits up to 1024 bits. </P><P>It is a simple programming task to produce a source code that allows for variable key and block sizes with up to 16,254 combinations of key and block sizes. It is important to note that a larger block size results in a larger internal key and thus longer setup times. The speed per byte of the encryption or decryption process does not depend significantly on the block size.</P><P>A 256 bit (32 bytes) key length is sufficient for defense against exhaustive key searching even under the most extreme assumptions. The fact that FROG allows up to 125 byte long keys means that the application can directly input the user's pass-word or passphrase without any previous pre-processing.</P><P>Variable block sizes can be extremely useful sometimes. For example, in the implementation of a confidential, random-access data base. The 1 byte increment of the block size permitted by FROG, means that such a data base can be encrypted without increasing the size of its records, resulting in higher speed encryption and greater ease of integration with existing applications. Another related example would be to encrypt only specific fields (columns) of a data base, regardless of their size. </P><P>Finally, it should be noted that FROG can implement directly the 64 bit block size and 112 bit key size of 3DES.</P><B><P><A NAME="b64"></A>B.6.4. Other Advantages</P></B><P>There is no speed penalty when using FROG with larger user key sizes (neither the key setup time nor the encryption/decryption speed depend on the user key size). </P><P>The relative complexity of the key setup process can be useful as a defense mechanism against dictionary attacks. If this is deemed useful then a version of FROG can be produced that executes more than one CBC encryption pass in the key setup process, which would produce arbitrarily long (variable) setup times.</P><P>A better defense against dictionary attacks is to modify the standard values of the <I>randomSeed </I>table. This can be done by initializing this table with a master key. Normally the master key would be administered centrally and end users would not need not know its value. In this case an attacker must find a way to obtain the master key before being able to mount a dictionary attack. Even in the case where the master key is simply stored on the end user's hard disk, the attacker's workload is significantly increased.</P><P>A defense that will work with all imaginable attack methods (except ciphertext only attacks which are exceedingly weak) is to use non standard versions of FROG where the actual code is different from the reference version. Then the attacker will have to find a way to steal a working copy of the cipher, disassemble it and then cryptanalyze it. This is clearly an enormously more difficult proposition than cryptanalyzing a publicly available standard version of the cipher. This kind of defense may be appropriate for applications that work within the confines of an organization, or applications for very sensitive point to point communications, etc.</P><P>Customization of the algorithm can be achieved in the following manner: the FROG cipher contains a small part that initializes the initial version of the internal key (<I>simpleKey</I>) as a function of both the user key and the <I>randomSeed</I> (or master key). This code fragment can be freely and easily be changed, even by a programmer who is not specialized in encryption technology, without affecting the strength of the algorithm. The only requirements are: a) the entropy of the user key is not lost in the process (which means, simply, that a different user key should always produce a different <I>simpleKey</I>); and b) that the user key contents are well spread out through the resulting initial internal key. In this way, an unlimited number of non standard versions of FROG can be produced, which are stronger than the standard version as long as the attacker does not gain access to them, and are as strong as the standard version in the worst case.</P><B><P><A NAME="b7"></A>B.7. Possible Future Developments</P></B><P>The simpler a cipher is the easier it is to detect a design flaw or a trap door. In this context it is considered important to investigate whether a version of FROG that omits the implementation of the first two conditions for the <I>bombPermu</I> array is not preferable even though it diffuses information a little slower. Changing the algorithm in this way would also have the effect of reducing the key setup time.</P><P>The key setup process can also be speeded up by using four iterations in the internal encryption process instead of eight (which are used to encrypt user data). This would practically double the speed of the setup process, and would probably not reduce the strength of the cipher.</P></FONT><P><FONT FACE="Arial" SIZE=2>Yet another possibility for speeding up the key setup process (at least on a Pentium processor) would be to use decrypts instead of encrypts in the process used to generate the internal key.</font> </P><P><HR><p></P><I></I><P ALIGN="RIGHT"><FONT FACE="Arial" SIZE=2><I>This page was last updated on December 18, 1998. Please report defects to </i></font><A HREF="mailto:webmaster@tecapro.com"><I><FONT FACE="Arial" SIZE=2>webmaster@tecapro.com</font></I></A><FONT FACE="Arial" SIZE=2>.<BR>(c)Copyright TecApro International 1998. All rights reserved.<BR></FONT><FONT FACE="Arial" SIZE=1>All registered trademarks mentioned are the property of their respective owners.</font></P><!--IWPEND-->  </td>  </tr>  </table><!--- fin main --->  <!--- menu tercer nivel --->  <table width="600" border="0" cellspacing="0" cellpadding="0">    <tr>       <td height="2"  bgcolor="#000000"><IMG alt="" border=0 height=5 src="img/blackline.jpg" width=600></td>    </tr>  </table><!--- fin menu tercer nivel --->     </div><!--- inicio abajo ---><div align="center">      <table width="600" border="0" cellspacing="0" cellpadding="0">    <tr>       <td><img src="img/realizado2.gif" width=68 height=35 border=0 alt=""> <a href="sinter-hermes.html"><img src="img/ani-hermes.gif" width=68 height=35 border=0 alt=""></a></td><td><font face="Arial" size="2">Para m&aacute;s informaci&oacute;n: <a href="mailto:tecapro@tecapro.com">tecapro@tecapro.com</a></font></td>    </tr>  </table></div><!--- fin abajo ---></body>
<!-- Mirrored from www.tecapro.com/aesfrog.html by HTTrack Website Copier/3.x [XR&CO'2004], Sat, 27 Nov 2004 22:44:55 GMT -->
</html>




<!--
     FILE ARCHIVED ON 16:42:34 Oct 30, 2005 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 14:28:31 Feb 5, 2017.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
